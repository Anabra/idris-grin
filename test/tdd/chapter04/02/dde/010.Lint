idris_int_eq.unboxed idris_int_eq0 idris_int_eq1 =
  (CGrInt idris_int_eq0_1) <- fetch idris_int_eq0
  (CGrInt idris_int_eq1_1) <- fetch idris_int_eq1
  idris_int_eq2 <- _prim_int_eq idris_int_eq0_1 idris_int_eq1_1
  ccp.0 <- case idris_int_eq2 of
    #False ->
      pure 0
    #True ->
      pure 1
  pure ccp.0 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idris_int_eq1_1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idris_int_eq0_1)

idris_int_lt.unboxed idris_int_lt0 idris_int_lt1.32.arity.1 =
  (CGrInt idris_int_lt0_1) <- fetch idris_int_lt0
  (CGrInt idris_int_lt1_1) <- pure (CGrInt idris_int_lt1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_int_lt2 <- _prim_int_lt idris_int_lt0_1 idris_int_lt1_1
  ccp.1 <- case idris_int_lt2 of
    #False ->
      pure 0
    #True ->
      pure 1
  pure ccp.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idris_int_lt0_1)

idris_int_add.unboxed idris_int_add0.32.arity.1 idris_int_add1.32.arity.1 =
  (CGrInt idris_int_add0_1) <- pure (CGrInt idris_int_add0.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  (CGrInt idris_int_add1_1) <- pure (CGrInt idris_int_add1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_int_add2 <- _prim_int_add idris_int_add0_1 idris_int_add1_1
  pure idris_int_add2

idris_int_sub.unboxed idris_int_sub0.32.arity.1 idris_int_sub1.32.arity.1 =
  (CGrInt idris_int_sub0_1) <- pure (CGrInt idris_int_sub0.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  (CGrInt idris_int_sub1_1) <- pure (CGrInt idris_int_sub1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_int_sub2 <- _prim_int_sub idris_int_sub0_1 idris_int_sub1_1
  pure idris_int_sub2

idris_write_str idris_write_str2 =
  (CGrString idris_write_str2_0) <- fetch idris_write_str2
  _prim_string_print idris_write_str2_0
  pure (CUnit) -- LINT: Last return expressions can only return non-node values: pure (CUnit) -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_write_str2_0)

idris_read_str.unboxed =
  idris_read_str1 <- _prim_read_string
  pure idris_read_str1

idris_str_concat idris_str_concat1 idris_str_concat2 =
  (CGrString idris_str_concat1_0) <- fetch idris_str_concat1
  (CGrString idris_str_concat2_0) <- fetch idris_str_concat2
  idris_str_concat3 <- _prim_string_concat idris_str_concat1_0 idris_str_concat2_0
  pure (CGrString idris_str_concat3) -- LINT: Last return expressions can only return non-node values: pure (CGrString idris_str_concat3) -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_str_concat2_0) -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_str_concat1_0)

idris_str_eq.unboxed idris_str_eq1 idris_str_eq2.32.arity.1 =
  (CGrString idris_str_eq1_0) <- fetch idris_str_eq1
  (CGrString idris_str_eq2_0) <- pure (CGrString idris_str_eq2.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_str_eq3 <- _prim_string_eq idris_str_eq1_0 idris_str_eq2_0
  ccp.2 <- case idris_str_eq3 of
    #False ->
      pure 0
    #True ->
      pure 1
  pure ccp.2 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_str_eq1_0)

idris_str_rev.unboxed idris_str_rev1.32.arity.1 =
  (CGrString idris_str_rev1_0) <- pure (CGrString idris_str_rev1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_str_rev2 <- _prim_string_reverse idris_str_rev1_0
  pure idris_str_rev2

idris_str_head.unboxed idris_str_head1 =
  (CGrString idris_str_head1_0) <- fetch idris_str_head1
  idris_str_head2 <- _prim_string_head idris_str_head1_0
  pure idris_str_head2 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_str_head1_0)

idris_str_tail.unboxed idris_str_tail1 =
  (CGrString idris_str_tail1_0) <- fetch idris_str_tail1
  idris_str_tail2 <- _prim_string_tail idris_str_tail1_0
  pure idris_str_tail2 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idris_str_tail1_0)

idris_str_cons.unboxed idris_str_cons1.32.arity.1 idris_str_cons2.32.arity.1 =
  (CGrInt idris_str_cons1_0) <- pure (CGrInt idris_str_cons1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  (CGrString idris_str_cons2_0) <- pure (CGrString idris_str_cons2.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_str_cons3 <- _prim_string_cons idris_str_cons1_0 idris_str_cons2_0
  pure idris_str_cons3

idris_int_str idris_int_str1 =
  (CGrInt idris_int_str1_0) <- fetch idris_int_str1
  idris_int_str2 <- _prim_int_str idris_int_str1_0
  pure (CGrString idris_int_str2) -- LINT: Last return expressions can only return non-node values: pure (CGrString idris_int_str2) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idris_int_str1_0)

idris_str_int.unboxed idris_str_int1.32.arity.1 =
  (CGrString idris_str_int1_0) <- pure (CGrString idris_str_int1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_str_int2 <- _prim_str_int idris_str_int1_0
  pure idris_str_int2

idris_ffi_file_eof.unboxed idris_ffi_file_eof1.32.arity.1 =
  (CGrInt idris_ffi_file_eof1_0) <- pure (CGrInt idris_ffi_file_eof1.32.arity.1) -- LINT: Syntax error - expected SimpleExp without nodes
  idris_ffi_file_eof2 <- _prim_ffi_file_eof idris_ffi_file_eof1_0
  pure idris_ffi_file_eof2

prim__stdin.unboxed =
  pure 0

grinMain =
  r <- "idr_{runMain_0}"
  pure ()

idr_PE_isInfixOf_22f242c8 idr_PE_isInfixOf_22f242c80 idr_PE_isInfixOf_22f242c81 =
  idr_PE_isInfixOf_22f242c82_val <- pure (CErased)
  idr_PE_isInfixOf_22f242c82 <- store idr_PE_isInfixOf_22f242c82_val
  idr_PE_isInfixOf_22f242c83_val <- pure (CErased)
  idr_PE_isInfixOf_22f242c83 <- store idr_PE_isInfixOf_22f242c83_val
  idr_PE_isInfixOf_22f242c84_val <- pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" idr_PE_isInfixOf_22f242c80)
  idr_PE_isInfixOf_22f242c84 <- store idr_PE_isInfixOf_22f242c84_val
  idr_PE_isInfixOf_22f242c85_val <- pure (Cidr_Prelude.Bool.False)
  idr_PE_isInfixOf_22f242c85 <- store idr_PE_isInfixOf_22f242c85_val
  idr_PE_isInfixOf_22f242c81_val <- fetch idr_PE_isInfixOf_22f242c81
  idr_PE_isInfixOf_22f242c86_val_1 <- case idr_PE_isInfixOf_22f242c81_val of
    (Cidr_Prelude.List.:: idr_PE_isInfixOf_22f242c86 idr_PE_isInfixOf_22f242c87) ->
      idr_PE_isInfixOf_22f242c88_val <- pure (CErased)
      idr_PE_isInfixOf_22f242c88 <- store idr_PE_isInfixOf_22f242c88_val
      idr_Prelude.List.tails idr_PE_isInfixOf_22f242c87
    (Cidr_Prelude.List.Nil) ->
      fetch idr_PE_isInfixOf_22f242c81
  idr_PE_isInfixOf_22f242c86_2 <- store idr_PE_isInfixOf_22f242c86_val_1
  idr_PE_isInfixOf_22f242c86_val <- pure (Cidr_Prelude.List.:: idr_PE_isInfixOf_22f242c81 idr_PE_isInfixOf_22f242c86_2)
  idr_PE_isInfixOf_22f242c86_3 <- store idr_PE_isInfixOf_22f242c86_val
  "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:0" idr_PE_isInfixOf_22f242c84 idr_PE_isInfixOf_22f242c85 idr_PE_isInfixOf_22f242c86_3

idr_Prelude.File.do_feof.unboxed idr_Prelude.File.do_feof0 =
  do
    (CGrInt idr_Prelude.File.do_feof0.32.0.arity.1) <- fetch idr_Prelude.File.do_feof0
    idris_ffi_file_eof.unboxed idr_Prelude.File.do_feof0.32.0.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Prelude.File.do_feof0.32.0.arity.1)

idr_Prelude.File.fEOF idr_Prelude.File.fEOF0 =
  idr_Prelude.File.fEOF2_val <- do
    unboxed.CGrInt.0 <- idr_Prelude.File.do_feof.unboxed idr_Prelude.File.fEOF0
    pure (CGrInt unboxed.CGrInt.0) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.0)
  idr_Prelude.File.fEOF2 <- store idr_Prelude.File.fEOF2_val
  idr_Prelude.File.fEOF3_val_8 <- pure (CGrInt 0)
  idr_Prelude.File.fEOF3 <- store idr_Prelude.File.fEOF3_val_8
  idr_Prelude.File.fEOF3_val <- do
    unboxed.CGrInt.1 <- idris_int_eq.unboxed idr_Prelude.File.fEOF2 idr_Prelude.File.fEOF3
    pure (CGrInt unboxed.CGrInt.1) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.1)
  idr_Prelude.File.fEOF3_9 <- store idr_Prelude.File.fEOF3_val
  idr_Prelude.File.fEOF3_val_10 <- fetch idr_Prelude.File.fEOF3_9
  case idr_Prelude.File.fEOF3_val_10 of
    (CGrInt idr_Prelude.File.fEOF_cpat_LInt64_0) ->
      case idr_Prelude.File.fEOF_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)

idr_Data.Fin.finToInteger.unboxed idr_Data.Fin.finToInteger1 =
  idr_Data.Fin.finToInteger1_val <- fetch idr_Data.Fin.finToInteger1
  case idr_Data.Fin.finToInteger1_val of
    (Cidr_Data.Fin.FS idr_Data.Fin.finToInteger2) ->
      idr_Data.Fin.finToInteger3_val <- pure (CGrInt 1)
      idr_Data.Fin.finToInteger3 <- store idr_Data.Fin.finToInteger3_val
      idr_Data.Fin.finToInteger4_val_11 <- pure (CErased)
      idr_Data.Fin.finToInteger4 <- store idr_Data.Fin.finToInteger4_val_11
      idr_Data.Fin.finToInteger4_val <- do
        unboxed.CGrInt.2 <- idr_Data.Fin.finToInteger.unboxed idr_Data.Fin.finToInteger2
        pure (CGrInt unboxed.CGrInt.2) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.2)
      idr_Data.Fin.finToInteger4_12 <- store idr_Data.Fin.finToInteger4_val
      do
        (CGrInt idr_Data.Fin.finToInteger3.32.1.arity.1) <- fetch idr_Data.Fin.finToInteger3
        (CGrInt idr_Data.Fin.finToInteger4_12.32.1.arity.1) <- fetch idr_Data.Fin.finToInteger4_12
        idris_int_add.unboxed idr_Data.Fin.finToInteger3.32.1.arity.1 idr_Data.Fin.finToInteger4_12.32.1.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.finToInteger4_12.32.1.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.finToInteger3.32.1.arity.1)
    (Cidr_Data.Fin.FZ) ->
      pure 0

idr_Data.Vect.foldrImpl idr_Data.Vect.foldrImpl3 idr_Data.Vect.foldrImpl4 idr_Data.Vect.foldrImpl5 idr_Data.Vect.foldrImpl6 =
  idr_Data.Vect.foldrImpl6_val <- fetch idr_Data.Vect.foldrImpl6
  case idr_Data.Vect.foldrImpl6_val of
    (Cidr_Data.Vect.:: idr_Data.Vect.foldrImpl7 idr_Data.Vect.foldrImpl8) ->
      idr_Data.Vect.foldrImpl9_val <- pure (CErased)
      idr_Data.Vect.foldrImpl9 <- store idr_Data.Vect.foldrImpl9_val
      idr_Data.Vect.foldrImpl10_val <- pure (CErased)
      idr_Data.Vect.foldrImpl10 <- store idr_Data.Vect.foldrImpl10_val
      idr_Data.Vect.foldrImpl11_val <- pure (CErased)
      idr_Data.Vect.foldrImpl11 <- store idr_Data.Vect.foldrImpl11_val
      idr_Data.Vect.foldrImpl12_val <- pure (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" idr_Data.Vect.foldrImpl5 idr_Data.Vect.foldrImpl3 idr_Data.Vect.foldrImpl7)
      idr_Data.Vect.foldrImpl12 <- store idr_Data.Vect.foldrImpl12_val
      idr_Data.Vect.foldrImpl idr_Data.Vect.foldrImpl3 idr_Data.Vect.foldrImpl4 idr_Data.Vect.foldrImpl12 idr_Data.Vect.foldrImpl8
    (Cidr_Data.Vect.Nil) ->
      do
        "idr_{APPLY_0}0.0" <- pure idr_Data.Vect.foldrImpl5
        "idr_{APPLY_0}1.0" <- pure idr_Data.Vect.foldrImpl4
        "idr_{APPLY_0}0_val.0" <- fetch "idr_{APPLY_0}0.0"
        case "idr_{APPLY_0}0_val.0" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.0" "idr_{APPLY_0}3.0" "idr_{APPLY_0}4.0") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.0" "idr_{APPLY_0}3.0" "idr_{APPLY_0}4.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.0") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.0") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.0") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.0" "idr_{APPLY_0}3_637.0") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.0" "idr_{APPLY_0}3_637.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.0"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.0" "idr_{APPLY_0}3_639.0" "idr_{APPLY_0}4_640.0" "idr_{APPLY_0}5.0") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.0" "idr_{APPLY_0}4_640.0" "idr_{APPLY_0}5.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.0") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.0"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.0" "idr_{APPLY_0}3_643.0" "idr_{APPLY_0}4_644.0") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.0" "idr_{APPLY_0}3_643.0" "idr_{APPLY_0}4_644.0"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.0"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.0") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.0" "idr_{APPLY_0}3_648.0") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.0" "idr_{APPLY_0}3_648.0" "idr_{APPLY_0}1.0"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.0")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.0")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.0")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.0") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.0" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.0" "idr_{APPLY_0}1.0")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.0")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.0") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.0" "idr_{APPLY_0}1.0") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.0" "idr_{APPLY_0}1.0")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)

idr_Main.getEntry idr_Main.getEntry0 idr_Main.getEntry1 =
  idr_Main.getEntry1_val <- fetch idr_Main.getEntry1
  (Cidr_Main.MkData idr_Main.getEntry2 idr_Main.getEntry3) <- pure idr_Main.getEntry1_val
  idr_Main.getEntry2_val_13 <- fetch idr_Main.getEntry2
  idr_Main.getEntry2_14 <- store idr_Main.getEntry2_val_13
  idr_Main.getEntry2_val <- idr_Data.Fin.integerToFin idr_Main.getEntry0 idr_Main.getEntry2_14
  idr_Main.getEntry2_15 <- store idr_Main.getEntry2_val
  idr_Main.getEntry2_val_16 <- fetch idr_Main.getEntry2_15
  ccp.3 <- case idr_Main.getEntry2_val_16 of
    (Cidr_Prelude.Maybe.Just idr_Main.getEntry3_17) ->
      idr_Main.getEntry4_val_20 <- pure (CErased)
      idr_Main.getEntry4 <- store idr_Main.getEntry4_val_20
      idr_Main.getEntry5_val <- pure (CErased)
      idr_Main.getEntry5 <- store idr_Main.getEntry5_val
      idr_Main.getEntry1_val_21 <- fetch idr_Main.getEntry1
      (Cidr_Main.MkData idr_Main.getEntry6 idr_Main.getEntry7) <- pure idr_Main.getEntry1_val_21
      idr_Main.getEntry6_val <- fetch idr_Main.getEntry7
      idr_Main.getEntry6_22 <- store idr_Main.getEntry6_val
      idr_Main.getEntry4_val_19 <- do
        unboxed.CGrString.1 <- idr_Data.Vect.index.unboxed idr_Main.getEntry3_17 idr_Main.getEntry6_22
        pure (CGrString unboxed.CGrString.1) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.1)
      idr_Main.getEntry4_23 <- store idr_Main.getEntry4_val_19
      idr_Main.getEntry5_val_24 <- pure (CGrString #"\n")
      idr_Main.getEntry5_25 <- store idr_Main.getEntry5_val_24
      idr_Main.getEntry4_val_18 <- idris_str_concat idr_Main.getEntry4_23 idr_Main.getEntry5_25
      idr_Main.getEntry4_26 <- store idr_Main.getEntry4_val_18
      idr_Main.getEntry4_val <- pure (Cidr_Builtins.MkPair idr_Main.getEntry4_26 idr_Main.getEntry1)
      idr_Main.getEntry4_27 <- store idr_Main.getEntry4_val
      pure idr_Main.getEntry4_27
    (Cidr_Prelude.Maybe.Nothing) ->
      idr_Main.getEntry3_val_28 <- pure (CGrString #"Out of range\n")
      idr_Main.getEntry3_29 <- store idr_Main.getEntry3_val_28
      idr_Main.getEntry3_val <- pure (Cidr_Builtins.MkPair idr_Main.getEntry3_29 idr_Main.getEntry1)
      idr_Main.getEntry3_30 <- store idr_Main.getEntry3_val
      pure idr_Main.getEntry3_30
  pure (Cidr_Prelude.Maybe.Just ccp.3) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just ccp.3)

idr_Prelude.Interactive.getLine'.unboxed =
  idr_Prelude.Interactive.getLine'2_val <- do
    unboxed.CGrString.2 <- idris_read_str.unboxed
    pure (CGrString unboxed.CGrString.2) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.2)
  idr_Prelude.Interactive.getLine'2 <- store idr_Prelude.Interactive.getLine'2_val
  idr_Prelude.Interactive.getLine'3_val_34 <- do
    unboxed.CGrString.3 <- do
      (CGrString idr_Prelude.Interactive.getLine'2.32.2.arity.1) <- fetch idr_Prelude.Interactive.getLine'2
      idris_str_rev.unboxed idr_Prelude.Interactive.getLine'2.32.2.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'2.32.2.arity.1)
    pure (CGrString unboxed.CGrString.3) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.3)
  idr_Prelude.Interactive.getLine'3 <- store idr_Prelude.Interactive.getLine'3_val_34
  idr_Prelude.Interactive.getLine'4_val <- pure (CGrString #"")
  idr_Prelude.Interactive.getLine'4 <- store idr_Prelude.Interactive.getLine'4_val
  idr_Prelude.Interactive.getLine'3_val_33 <- do
    unboxed.CGrInt.3 <- do
      (CGrString idr_Prelude.Interactive.getLine'4.32.3.arity.1) <- fetch idr_Prelude.Interactive.getLine'4
      idris_str_eq.unboxed idr_Prelude.Interactive.getLine'3 idr_Prelude.Interactive.getLine'4.32.3.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'4.32.3.arity.1)
    pure (CGrInt unboxed.CGrInt.3) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.3)
  idr_Prelude.Interactive.getLine'3_35 <- store idr_Prelude.Interactive.getLine'3_val_33
  idr_Prelude.Interactive.getLine'3_val_36 <- fetch idr_Prelude.Interactive.getLine'3_35
  idr_Prelude.Interactive.getLine'3_val_32 <- case idr_Prelude.Interactive.getLine'3_val_36 of
    (CGrInt idr_Prelude.Interactive.getLine'_cpat_LInt64_0) ->
      case idr_Prelude.Interactive.getLine'_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
  idr_Prelude.Interactive.getLine'3_37 <- store idr_Prelude.Interactive.getLine'3_val_32
  idr_Prelude.Interactive.getLine'4_val_38 <- pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Interactive.getLine'4_39 <- store idr_Prelude.Interactive.getLine'4_val_38
  idr_Prelude.Interactive.getLine'3_val_31 <- do
    (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Interactive.getLine'4_39
    "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Interactive.getLine'3_37 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
  idr_Prelude.Interactive.getLine'3_40 <- store idr_Prelude.Interactive.getLine'3_val_31
  idr_Prelude.Interactive.getLine'3_val_41 <- fetch idr_Prelude.Interactive.getLine'3_40
  idr_Prelude.Interactive.getLine'3_val <- case idr_Prelude.Interactive.getLine'3_val_41 of
    (Cidr_Prelude.Basics.No) ->
      pure (CGrString #"") -- LINT: Last return expressions can only return non-node values: pure (CGrString #"")
    (Cidr_Prelude.Basics.Yes) ->
      idr_Prelude.Interactive.getLine'4_val_43 <- do
        unboxed.CGrString.4 <- do
          (CGrString idr_Prelude.Interactive.getLine'2.32.5.arity.1) <- fetch idr_Prelude.Interactive.getLine'2
          idris_str_rev.unboxed idr_Prelude.Interactive.getLine'2.32.5.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'2.32.5.arity.1)
        pure (CGrString unboxed.CGrString.4) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.4)
      idr_Prelude.Interactive.getLine'4_44 <- store idr_Prelude.Interactive.getLine'4_val_43
      idr_Prelude.Interactive.getLine'4_val_42 <- do
        unboxed.CGrInt.4 <- idris_str_head.unboxed idr_Prelude.Interactive.getLine'4_44
        pure (CGrInt unboxed.CGrInt.4) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.4)
      idr_Prelude.Interactive.getLine'4_45 <- store idr_Prelude.Interactive.getLine'4_val_42
      idr_Prelude.Interactive.getLine'4_val_46 <- fetch idr_Prelude.Interactive.getLine'4_45
      case idr_Prelude.Interactive.getLine'4_val_46 of
        (CGrInt idr_Prelude.Interactive.getLine'_cpat_LInt64_10) ->
          case idr_Prelude.Interactive.getLine'_cpat_LInt64_10 of
            10 ->
              idr_Prelude.Interactive.getLine'5_val <- do
                unboxed.CGrString.5 <- do
                  (CGrString idr_Prelude.Interactive.getLine'2.32.6.arity.1) <- fetch idr_Prelude.Interactive.getLine'2
                  idris_str_rev.unboxed idr_Prelude.Interactive.getLine'2.32.6.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'2.32.6.arity.1)
                pure (CGrString unboxed.CGrString.5) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.5)
              idr_Prelude.Interactive.getLine'5 <- store idr_Prelude.Interactive.getLine'5_val
              do
                unboxed.CGrString.6 <- idris_str_tail.unboxed idr_Prelude.Interactive.getLine'5
                pure (CGrString unboxed.CGrString.6) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.6)
            #default ->
              idr_Prelude.Interactive.getLine'5_val_48 <- do
                unboxed.CGrString.7 <- do
                  (CGrString idr_Prelude.Interactive.getLine'2.32.7.arity.1) <- fetch idr_Prelude.Interactive.getLine'2
                  idris_str_rev.unboxed idr_Prelude.Interactive.getLine'2.32.7.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'2.32.7.arity.1)
                pure (CGrString unboxed.CGrString.7) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.7)
              idr_Prelude.Interactive.getLine'5_49 <- store idr_Prelude.Interactive.getLine'5_val_48
              idr_Prelude.Interactive.getLine'5_val_47 <- do
                unboxed.CGrInt.5 <- idris_str_head.unboxed idr_Prelude.Interactive.getLine'5_49
                pure (CGrInt unboxed.CGrInt.5) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.5)
              idr_Prelude.Interactive.getLine'5_50 <- store idr_Prelude.Interactive.getLine'5_val_47
              idr_Prelude.Interactive.getLine'6_val_51 <- do
                unboxed.CGrString.8 <- do
                  (CGrString idr_Prelude.Interactive.getLine'2.32.8.arity.1) <- fetch idr_Prelude.Interactive.getLine'2
                  idris_str_rev.unboxed idr_Prelude.Interactive.getLine'2.32.8.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'2.32.8.arity.1)
                pure (CGrString unboxed.CGrString.8) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.8)
              idr_Prelude.Interactive.getLine'6 <- store idr_Prelude.Interactive.getLine'6_val_51
              idr_Prelude.Interactive.getLine'6_val <- do
                unboxed.CGrString.9 <- idris_str_tail.unboxed idr_Prelude.Interactive.getLine'6
                pure (CGrString unboxed.CGrString.9) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.9)
              idr_Prelude.Interactive.getLine'6_52 <- store idr_Prelude.Interactive.getLine'6_val
              do
                unboxed.CGrString.10 <- do
                  (CGrInt idr_Prelude.Interactive.getLine'5_50.32.9.arity.1) <- fetch idr_Prelude.Interactive.getLine'5_50
                  (CGrString idr_Prelude.Interactive.getLine'6_52.32.9.arity.1) <- fetch idr_Prelude.Interactive.getLine'6_52
                  idris_str_cons.unboxed idr_Prelude.Interactive.getLine'5_50.32.9.arity.1 idr_Prelude.Interactive.getLine'6_52.32.9.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'6_52.32.9.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Prelude.Interactive.getLine'5_50.32.9.arity.1)
                pure (CGrString unboxed.CGrString.10) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.10)
  idr_Prelude.Interactive.getLine'3_61 <- store idr_Prelude.Interactive.getLine'3_val
  do
    (CGrString idr_Prelude.Interactive.getLine'3_61.32.10.arity.1) <- fetch idr_Prelude.Interactive.getLine'3_61
    idris_str_rev.unboxed idr_Prelude.Interactive.getLine'3_61.32.10.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Interactive.getLine'3_61.32.10.arity.1)

idr_Data.Vect.index.unboxed idr_Data.Vect.index2 idr_Data.Vect.index3 =
  idr_Data.Vect.index2_val <- fetch idr_Data.Vect.index2
  case idr_Data.Vect.index2_val of
    (Cidr_Data.Fin.FS idr_Data.Vect.index4) ->
      idr_Data.Vect.index3_val <- fetch idr_Data.Vect.index3
      (Cidr_Data.Vect.:: idr_Data.Vect.index5 idr_Data.Vect.index6) <- pure idr_Data.Vect.index3_val
      idr_Data.Vect.index7_val <- pure (CErased)
      idr_Data.Vect.index7 <- store idr_Data.Vect.index7_val
      idr_Data.Vect.index8_val <- pure (CErased)
      idr_Data.Vect.index8 <- store idr_Data.Vect.index8_val
      idr_Data.Vect.index.unboxed idr_Data.Vect.index4 idr_Data.Vect.index6
    (Cidr_Data.Fin.FZ) ->
      idr_Data.Vect.index3_val_62 <- fetch idr_Data.Vect.index3
      (Cidr_Data.Vect.:: idr_Data.Vect.index4_63 idr_Data.Vect.index5_64) <- pure idr_Data.Vect.index3_val_62
      do
        (CGrString unboxed.CGrString.0) <- fetch idr_Data.Vect.index4_63
        pure unboxed.CGrString.0 -- LINT: The result of Fetch can only be bound to a variable: (CGrString unboxed.CGrString.0)

idr_Data.Fin.integerToFin idr_Data.Fin.integerToFin0 idr_Data.Fin.integerToFin1 =
  idr_Data.Fin.integerToFin1_val <- fetch idr_Data.Fin.integerToFin1
  case idr_Data.Fin.integerToFin1_val of
    (CGrInt idr_Data.Fin.integerToFin_cpat_LInt64_0) ->
      case idr_Data.Fin.integerToFin_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
        #default ->
          idr_Data.Fin.integerToFin2_val_66 <- pure (CGrInt 0)
          idr_Data.Fin.integerToFin2 <- store idr_Data.Fin.integerToFin2_val_66
          idr_Data.Fin.integerToFin2_val_65 <- "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0" idr_Data.Fin.integerToFin0 idr_Data.Fin.integerToFin2
          idr_Data.Fin.integerToFin2_67 <- store idr_Data.Fin.integerToFin2_val_65
          idr_Data.Fin.integerToFin2_val_68 <- fetch idr_Data.Fin.integerToFin2_67
          idr_Data.Fin.integerToFin2_val <- case idr_Data.Fin.integerToFin2_val_68 of
            (Cidr_Prelude.Interfaces.GT) ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
            #default ->
              idr_Data.Fin.integerToFin3_val_69 <- pure (CGrInt 0)
              idr_Data.Fin.integerToFin3 <- store idr_Data.Fin.integerToFin3_val_69
              idr_Data.Fin.integerToFin3_val <- do
                unboxed.CGrInt.6 <- idris_int_eq.unboxed idr_Data.Fin.integerToFin0 idr_Data.Fin.integerToFin3
                pure (CGrInt unboxed.CGrInt.6) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.6)
              idr_Data.Fin.integerToFin3_70 <- store idr_Data.Fin.integerToFin3_val
              idr_Data.Fin.integerToFin3_val_71 <- fetch idr_Data.Fin.integerToFin3_70
              case idr_Data.Fin.integerToFin3_val_71 of
                (CGrInt idr_Data.Fin.integerToFin_cpat_LInt64_0_72) ->
                  case idr_Data.Fin.integerToFin_cpat_LInt64_0_72 of
                    0 ->
                      pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
                    #default ->
                      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
          idr_Data.Fin.integerToFin2_73 <- store idr_Data.Fin.integerToFin2_val
          idr_Data.Fin.integerToFin2_val_74 <- fetch idr_Data.Fin.integerToFin2_73
          case idr_Data.Fin.integerToFin2_val_74 of
            (Cidr_Prelude.Bool.False) ->
              pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
            (Cidr_Prelude.Bool.True) ->
              idr_Data.Fin.natToFin idr_Data.Fin.integerToFin0 idr_Data.Fin.integerToFin1

idr_io_bind idr_io_bind3 idr_io_bind4 idr_io_bind5 =
  idr_io_bind6_val_89 <- do
    "idr_{APPLY_0}0.1" <- pure idr_io_bind3
    "idr_{APPLY_0}1.1" <- pure idr_io_bind5
    "idr_{APPLY_0}0_val.1" <- fetch "idr_{APPLY_0}0.1"
    case "idr_{APPLY_0}0_val.1" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.1" "idr_{APPLY_0}3.1" "idr_{APPLY_0}4.1") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.1" "idr_{APPLY_0}3.1" "idr_{APPLY_0}4.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.1") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.1") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.1") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.1" "idr_{APPLY_0}3_637.1") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.1" "idr_{APPLY_0}3_637.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.1"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.1" "idr_{APPLY_0}3_639.1" "idr_{APPLY_0}4_640.1" "idr_{APPLY_0}5.1") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.1" "idr_{APPLY_0}4_640.1" "idr_{APPLY_0}5.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.1") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.1"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.1" "idr_{APPLY_0}3_643.1" "idr_{APPLY_0}4_644.1") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.1" "idr_{APPLY_0}3_643.1" "idr_{APPLY_0}4_644.1"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.1"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.1") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.1" "idr_{APPLY_0}3_648.1") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.1" "idr_{APPLY_0}3_648.1" "idr_{APPLY_0}1.1"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.1")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.1")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.1")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.1") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.1" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.1" "idr_{APPLY_0}1.1")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.1")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.1") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.1" "idr_{APPLY_0}1.1") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.1" "idr_{APPLY_0}1.1")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
  idr_io_bind6 <- store idr_io_bind6_val_89
  idr_io_bind6_val <- do
    "idr_{APPLY_0}0.2" <- pure idr_io_bind4
    "idr_{APPLY_0}1.2" <- pure idr_io_bind6
    "idr_{APPLY_0}0_val.2" <- fetch "idr_{APPLY_0}0.2"
    case "idr_{APPLY_0}0_val.2" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.2" "idr_{APPLY_0}3.2" "idr_{APPLY_0}4.2") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.2" "idr_{APPLY_0}3.2" "idr_{APPLY_0}4.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.2") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.2") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.2") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.2" "idr_{APPLY_0}3_637.2") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.2" "idr_{APPLY_0}3_637.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.2"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.2" "idr_{APPLY_0}3_639.2" "idr_{APPLY_0}4_640.2" "idr_{APPLY_0}5.2") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.2" "idr_{APPLY_0}4_640.2" "idr_{APPLY_0}5.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.2") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.2"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.2" "idr_{APPLY_0}3_643.2" "idr_{APPLY_0}4_644.2") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.2" "idr_{APPLY_0}3_643.2" "idr_{APPLY_0}4_644.2"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.2"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.2") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.2" "idr_{APPLY_0}3_648.2") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.2" "idr_{APPLY_0}3_648.2" "idr_{APPLY_0}1.2"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.2")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.2")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.2")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.2") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.2" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.2" "idr_{APPLY_0}1.2")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.2")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.2") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.2" "idr_{APPLY_0}1.2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.2" "idr_{APPLY_0}1.2")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
  idr_io_bind6_90 <- store idr_io_bind6_val
  do
    "idr_{APPLY_0}0.3" <- pure idr_io_bind6_90
    "idr_{APPLY_0}1.3" <- pure idr_io_bind5
    "idr_{APPLY_0}0_val.3" <- fetch "idr_{APPLY_0}0.3"
    case "idr_{APPLY_0}0_val.3" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.3" "idr_{APPLY_0}3.3" "idr_{APPLY_0}4.3") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.3" "idr_{APPLY_0}3.3" "idr_{APPLY_0}4.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.3") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.3") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.3") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.3" "idr_{APPLY_0}3_637.3") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.3" "idr_{APPLY_0}3_637.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.3"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.3" "idr_{APPLY_0}3_639.3" "idr_{APPLY_0}4_640.3" "idr_{APPLY_0}5.3") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.3" "idr_{APPLY_0}4_640.3" "idr_{APPLY_0}5.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.3") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.3"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.3" "idr_{APPLY_0}3_643.3" "idr_{APPLY_0}4_644.3") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.3" "idr_{APPLY_0}3_643.3" "idr_{APPLY_0}4_644.3"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.3"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.3") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.3" "idr_{APPLY_0}3_648.3") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.3" "idr_{APPLY_0}3_648.3" "idr_{APPLY_0}1.3"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.3")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.3")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.3")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.3") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.3" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.3" "idr_{APPLY_0}1.3")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.3")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.3") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.3" "idr_{APPLY_0}1.3") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.3" "idr_{APPLY_0}1.3")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)

idr_Prelude.Chars.isDigit idr_Prelude.Chars.isDigit0 =
  idr_Prelude.Chars.isDigit1_val_92 <- pure (CGrInt 48)
  idr_Prelude.Chars.isDigit1 <- store idr_Prelude.Chars.isDigit1_val_92
  idr_Prelude.Chars.isDigit1_val_91 <- "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0" idr_Prelude.Chars.isDigit0 idr_Prelude.Chars.isDigit1
  idr_Prelude.Chars.isDigit1_93 <- store idr_Prelude.Chars.isDigit1_val_91
  idr_Prelude.Chars.isDigit1_val_94 <- fetch idr_Prelude.Chars.isDigit1_93
  idr_Prelude.Chars.isDigit1_val <- case idr_Prelude.Chars.isDigit1_val_94 of
    (Cidr_Prelude.Interfaces.GT) ->
      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
    #default ->
      idr_Prelude.Chars.isDigit2_val_95 <- pure (CGrInt 48)
      idr_Prelude.Chars.isDigit2 <- store idr_Prelude.Chars.isDigit2_val_95
      idr_Prelude.Chars.isDigit2_val <- do
        unboxed.CGrInt.7 <- idris_int_eq.unboxed idr_Prelude.Chars.isDigit0 idr_Prelude.Chars.isDigit2
        pure (CGrInt unboxed.CGrInt.7) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.7)
      idr_Prelude.Chars.isDigit2_96 <- store idr_Prelude.Chars.isDigit2_val
      idr_Prelude.Chars.isDigit2_val_97 <- fetch idr_Prelude.Chars.isDigit2_96
      case idr_Prelude.Chars.isDigit2_val_97 of
        (CGrInt idr_Prelude.Chars.isDigit_cpat_LInt64_0) ->
          case idr_Prelude.Chars.isDigit_cpat_LInt64_0 of
            0 ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
            #default ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Chars.isDigit1_98 <- store idr_Prelude.Chars.isDigit1_val
  idr_Prelude.Chars.isDigit1_val_99 <- fetch idr_Prelude.Chars.isDigit1_98
  case idr_Prelude.Chars.isDigit1_val_99 of
    (Cidr_Prelude.Bool.False) ->
      pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
    (Cidr_Prelude.Bool.True) ->
      idr_Prelude.Chars.isDigit2_val_101 <- pure (CGrInt 57)
      idr_Prelude.Chars.isDigit2_102 <- store idr_Prelude.Chars.isDigit2_val_101
      idr_Prelude.Chars.isDigit2_val_100 <- "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0" idr_Prelude.Chars.isDigit0 idr_Prelude.Chars.isDigit2_102
      idr_Prelude.Chars.isDigit2_103 <- store idr_Prelude.Chars.isDigit2_val_100
      idr_Prelude.Chars.isDigit2_val_104 <- fetch idr_Prelude.Chars.isDigit2_103
      case idr_Prelude.Chars.isDigit2_val_104 of
        (Cidr_Prelude.Interfaces.LT) ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          idr_Prelude.Chars.isDigit3_val_105 <- pure (CGrInt 57)
          idr_Prelude.Chars.isDigit3 <- store idr_Prelude.Chars.isDigit3_val_105
          idr_Prelude.Chars.isDigit3_val <- do
            unboxed.CGrInt.8 <- idris_int_eq.unboxed idr_Prelude.Chars.isDigit0 idr_Prelude.Chars.isDigit3
            pure (CGrInt unboxed.CGrInt.8) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.8)
          idr_Prelude.Chars.isDigit3_106 <- store idr_Prelude.Chars.isDigit3_val
          idr_Prelude.Chars.isDigit3_val_107 <- fetch idr_Prelude.Chars.isDigit3_106
          case idr_Prelude.Chars.isDigit3_val_107 of
            (CGrInt idr_Prelude.Chars.isDigit_cpat_LInt64_0_108) ->
              case idr_Prelude.Chars.isDigit_cpat_LInt64_0_108 of
                0 ->
                  pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
                #default ->
                  pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)

idr_Prelude.Strings.isInfixOf idr_Prelude.Strings.isInfixOf0 idr_Prelude.Strings.isInfixOf1 =
  idr_Prelude.Strings.isInfixOf2_val_112 <- pure (CGrString #"")
  idr_Prelude.Strings.isInfixOf2 <- store idr_Prelude.Strings.isInfixOf2_val_112
  idr_Prelude.Strings.isInfixOf2_val_111 <- do
    unboxed.CGrInt.9 <- do
      (CGrString idr_Prelude.Strings.isInfixOf2.32.11.arity.1) <- fetch idr_Prelude.Strings.isInfixOf2
      idris_str_eq.unboxed idr_Prelude.Strings.isInfixOf0 idr_Prelude.Strings.isInfixOf2.32.11.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Strings.isInfixOf2.32.11.arity.1)
    pure (CGrInt unboxed.CGrInt.9) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.9)
  idr_Prelude.Strings.isInfixOf2_113 <- store idr_Prelude.Strings.isInfixOf2_val_111
  idr_Prelude.Strings.isInfixOf2_val_114 <- fetch idr_Prelude.Strings.isInfixOf2_113
  idr_Prelude.Strings.isInfixOf2_val_110 <- case idr_Prelude.Strings.isInfixOf2_val_114 of
    (CGrInt idr_Prelude.Strings.isInfixOf_cpat_LInt64_0) ->
      case idr_Prelude.Strings.isInfixOf_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
  idr_Prelude.Strings.isInfixOf2_115 <- store idr_Prelude.Strings.isInfixOf2_val_110
  idr_Prelude.Strings.isInfixOf3_val <- pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Strings.isInfixOf3 <- store idr_Prelude.Strings.isInfixOf3_val
  idr_Prelude.Strings.isInfixOf2_val_109 <- do
    (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Strings.isInfixOf3
    "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Strings.isInfixOf2_115 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
  idr_Prelude.Strings.isInfixOf2_116 <- store idr_Prelude.Strings.isInfixOf2_val_109
  idr_Prelude.Strings.isInfixOf2_val_117 <- fetch idr_Prelude.Strings.isInfixOf2_116
  idr_Prelude.Strings.isInfixOf2_val <- case idr_Prelude.Strings.isInfixOf2_val_117 of
    (Cidr_Prelude.Basics.No) ->
      pure (Cidr_Prelude.List.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.Nil)
    (Cidr_Prelude.Basics.Yes) ->
      idr_Prelude.Strings.isInfixOf3_val_118 <- do
        unboxed.CGrInt.10 <- idris_str_head.unboxed idr_Prelude.Strings.isInfixOf0
        pure (CGrInt unboxed.CGrInt.10) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.10)
      idr_Prelude.Strings.isInfixOf3_119 <- store idr_Prelude.Strings.isInfixOf3_val_118
      idr_Prelude.Strings.isInfixOf4_val_120 <- pure (CErased)
      idr_Prelude.Strings.isInfixOf4 <- store idr_Prelude.Strings.isInfixOf4_val_120
      idr_Prelude.Strings.isInfixOf5_val_124 <- do
        unboxed.CGrString.11 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf0
        pure (CGrString unboxed.CGrString.11) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.11)
      idr_Prelude.Strings.isInfixOf5 <- store idr_Prelude.Strings.isInfixOf5_val_124
      idr_Prelude.Strings.isInfixOf6_val <- pure (CGrString #"")
      idr_Prelude.Strings.isInfixOf6 <- store idr_Prelude.Strings.isInfixOf6_val
      idr_Prelude.Strings.isInfixOf5_val_123 <- do
        unboxed.CGrInt.11 <- do
          (CGrString idr_Prelude.Strings.isInfixOf6.32.13.arity.1) <- fetch idr_Prelude.Strings.isInfixOf6
          idris_str_eq.unboxed idr_Prelude.Strings.isInfixOf5 idr_Prelude.Strings.isInfixOf6.32.13.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Strings.isInfixOf6.32.13.arity.1)
        pure (CGrInt unboxed.CGrInt.11) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.11)
      idr_Prelude.Strings.isInfixOf5_125 <- store idr_Prelude.Strings.isInfixOf5_val_123
      idr_Prelude.Strings.isInfixOf5_val_126 <- fetch idr_Prelude.Strings.isInfixOf5_125
      idr_Prelude.Strings.isInfixOf5_val_122 <- case idr_Prelude.Strings.isInfixOf5_val_126 of
        (CGrInt idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_127) ->
          case idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_127 of
            0 ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
            #default ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
      idr_Prelude.Strings.isInfixOf5_128 <- store idr_Prelude.Strings.isInfixOf5_val_122
      idr_Prelude.Strings.isInfixOf6_val_129 <- pure (Cidr_Prelude.Bool.True)
      idr_Prelude.Strings.isInfixOf6_130 <- store idr_Prelude.Strings.isInfixOf6_val_129
      idr_Prelude.Strings.isInfixOf5_val_121 <- do
        (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Strings.isInfixOf6_130
        "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Strings.isInfixOf5_128 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
      idr_Prelude.Strings.isInfixOf5_131 <- store idr_Prelude.Strings.isInfixOf5_val_121
      idr_Prelude.Strings.isInfixOf5_val_132 <- fetch idr_Prelude.Strings.isInfixOf5_131
      idr_Prelude.Strings.isInfixOf5_val <- case idr_Prelude.Strings.isInfixOf5_val_132 of
        (Cidr_Prelude.Basics.No) ->
          pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
        (Cidr_Prelude.Basics.Yes) ->
          idr_Prelude.Strings.isInfixOf6_val_134 <- do
            unboxed.CGrString.12 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf0
            pure (CGrString unboxed.CGrString.12) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.12)
          idr_Prelude.Strings.isInfixOf6_135 <- store idr_Prelude.Strings.isInfixOf6_val_134
          idr_Prelude.Strings.isInfixOf6_val_133 <- do
            unboxed.CGrInt.12 <- idris_str_head.unboxed idr_Prelude.Strings.isInfixOf6_135
            pure (CGrInt unboxed.CGrInt.12) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.12)
          idr_Prelude.Strings.isInfixOf6_136 <- store idr_Prelude.Strings.isInfixOf6_val_133
          idr_Prelude.Strings.isInfixOf7_val_137 <- do
            unboxed.CGrString.13 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf0
            pure (CGrString unboxed.CGrString.13) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.13)
          idr_Prelude.Strings.isInfixOf7 <- store idr_Prelude.Strings.isInfixOf7_val_137
          idr_Prelude.Strings.isInfixOf7_val <- do
            unboxed.CGrString.14 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf7
            pure (CGrString unboxed.CGrString.14) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.14)
          idr_Prelude.Strings.isInfixOf7_138 <- store idr_Prelude.Strings.isInfixOf7_val
          pure (Cidr_Prelude.Strings.StrCons idr_Prelude.Strings.isInfixOf6_136 idr_Prelude.Strings.isInfixOf7_138) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr_Prelude.Strings.isInfixOf6_136 idr_Prelude.Strings.isInfixOf7_138)
      idr_Prelude.Strings.isInfixOf5_139 <- store idr_Prelude.Strings.isInfixOf5_val
      idr_Prelude.Strings.isInfixOf4_val <- idr__Prelude.Strings.unpack_with_36 idr_Prelude.Strings.isInfixOf5_139
      idr_Prelude.Strings.isInfixOf4_140 <- store idr_Prelude.Strings.isInfixOf4_val
      pure (Cidr_Prelude.List.:: idr_Prelude.Strings.isInfixOf3_119 idr_Prelude.Strings.isInfixOf4_140) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr_Prelude.Strings.isInfixOf3_119 idr_Prelude.Strings.isInfixOf4_140)
  idr_Prelude.Strings.isInfixOf2_141 <- store idr_Prelude.Strings.isInfixOf2_val
  idr_Prelude.Strings.isInfixOf3_val_146 <- pure (CGrString #"")
  idr_Prelude.Strings.isInfixOf3_147 <- store idr_Prelude.Strings.isInfixOf3_val_146
  idr_Prelude.Strings.isInfixOf3_val_145 <- do
    unboxed.CGrInt.13 <- do
      (CGrString idr_Prelude.Strings.isInfixOf3_147.32.15.arity.1) <- fetch idr_Prelude.Strings.isInfixOf3_147
      idris_str_eq.unboxed idr_Prelude.Strings.isInfixOf1 idr_Prelude.Strings.isInfixOf3_147.32.15.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Strings.isInfixOf3_147.32.15.arity.1)
    pure (CGrInt unboxed.CGrInt.13) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.13)
  idr_Prelude.Strings.isInfixOf3_148 <- store idr_Prelude.Strings.isInfixOf3_val_145
  idr_Prelude.Strings.isInfixOf3_val_149 <- fetch idr_Prelude.Strings.isInfixOf3_148
  idr_Prelude.Strings.isInfixOf3_val_144 <- case idr_Prelude.Strings.isInfixOf3_val_149 of
    (CGrInt idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_150) ->
      case idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_150 of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
  idr_Prelude.Strings.isInfixOf3_151 <- store idr_Prelude.Strings.isInfixOf3_val_144
  idr_Prelude.Strings.isInfixOf4_val_152 <- pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Strings.isInfixOf4_153 <- store idr_Prelude.Strings.isInfixOf4_val_152
  idr_Prelude.Strings.isInfixOf3_val_143 <- do
    (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Strings.isInfixOf4_153
    "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Strings.isInfixOf3_151 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
  idr_Prelude.Strings.isInfixOf3_154 <- store idr_Prelude.Strings.isInfixOf3_val_143
  idr_Prelude.Strings.isInfixOf3_val_155 <- fetch idr_Prelude.Strings.isInfixOf3_154
  idr_Prelude.Strings.isInfixOf3_val_142 <- case idr_Prelude.Strings.isInfixOf3_val_155 of
    (Cidr_Prelude.Basics.No) ->
      pure (Cidr_Prelude.List.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.Nil)
    (Cidr_Prelude.Basics.Yes) ->
      idr_Prelude.Strings.isInfixOf4_val_156 <- do
        unboxed.CGrInt.14 <- idris_str_head.unboxed idr_Prelude.Strings.isInfixOf1
        pure (CGrInt unboxed.CGrInt.14) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.14)
      idr_Prelude.Strings.isInfixOf4_157 <- store idr_Prelude.Strings.isInfixOf4_val_156
      idr_Prelude.Strings.isInfixOf5_val_159 <- pure (CErased)
      idr_Prelude.Strings.isInfixOf5_160 <- store idr_Prelude.Strings.isInfixOf5_val_159
      idr_Prelude.Strings.isInfixOf6_val_165 <- do
        unboxed.CGrString.15 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf1
        pure (CGrString unboxed.CGrString.15) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.15)
      idr_Prelude.Strings.isInfixOf6_166 <- store idr_Prelude.Strings.isInfixOf6_val_165
      idr_Prelude.Strings.isInfixOf7_val_167 <- pure (CGrString #"")
      idr_Prelude.Strings.isInfixOf7_168 <- store idr_Prelude.Strings.isInfixOf7_val_167
      idr_Prelude.Strings.isInfixOf6_val_164 <- do
        unboxed.CGrInt.15 <- do
          (CGrString idr_Prelude.Strings.isInfixOf7_168.32.17.arity.1) <- fetch idr_Prelude.Strings.isInfixOf7_168
          idris_str_eq.unboxed idr_Prelude.Strings.isInfixOf6_166 idr_Prelude.Strings.isInfixOf7_168.32.17.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Strings.isInfixOf7_168.32.17.arity.1)
        pure (CGrInt unboxed.CGrInt.15) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.15)
      idr_Prelude.Strings.isInfixOf6_169 <- store idr_Prelude.Strings.isInfixOf6_val_164
      idr_Prelude.Strings.isInfixOf6_val_170 <- fetch idr_Prelude.Strings.isInfixOf6_169
      idr_Prelude.Strings.isInfixOf6_val_163 <- case idr_Prelude.Strings.isInfixOf6_val_170 of
        (CGrInt idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_171) ->
          case idr_Prelude.Strings.isInfixOf_cpat_LInt64_0_171 of
            0 ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
            #default ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
      idr_Prelude.Strings.isInfixOf6_172 <- store idr_Prelude.Strings.isInfixOf6_val_163
      idr_Prelude.Strings.isInfixOf7_val_173 <- pure (Cidr_Prelude.Bool.True)
      idr_Prelude.Strings.isInfixOf7_174 <- store idr_Prelude.Strings.isInfixOf7_val_173
      idr_Prelude.Strings.isInfixOf6_val_162 <- do
        (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Strings.isInfixOf7_174
        "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Strings.isInfixOf6_172 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
      idr_Prelude.Strings.isInfixOf6_175 <- store idr_Prelude.Strings.isInfixOf6_val_162
      idr_Prelude.Strings.isInfixOf6_val_176 <- fetch idr_Prelude.Strings.isInfixOf6_175
      idr_Prelude.Strings.isInfixOf6_val_161 <- case idr_Prelude.Strings.isInfixOf6_val_176 of
        (Cidr_Prelude.Basics.No) ->
          pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
        (Cidr_Prelude.Basics.Yes) ->
          idr_Prelude.Strings.isInfixOf7_val_178 <- do
            unboxed.CGrString.16 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf1
            pure (CGrString unboxed.CGrString.16) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.16)
          idr_Prelude.Strings.isInfixOf7_179 <- store idr_Prelude.Strings.isInfixOf7_val_178
          idr_Prelude.Strings.isInfixOf7_val_177 <- do
            unboxed.CGrInt.16 <- idris_str_head.unboxed idr_Prelude.Strings.isInfixOf7_179
            pure (CGrInt unboxed.CGrInt.16) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.16)
          idr_Prelude.Strings.isInfixOf7_180 <- store idr_Prelude.Strings.isInfixOf7_val_177
          idr_Prelude.Strings.isInfixOf8_val_181 <- do
            unboxed.CGrString.17 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf1
            pure (CGrString unboxed.CGrString.17) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.17)
          idr_Prelude.Strings.isInfixOf8 <- store idr_Prelude.Strings.isInfixOf8_val_181
          idr_Prelude.Strings.isInfixOf8_val <- do
            unboxed.CGrString.18 <- idris_str_tail.unboxed idr_Prelude.Strings.isInfixOf8
            pure (CGrString unboxed.CGrString.18) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.18)
          idr_Prelude.Strings.isInfixOf8_182 <- store idr_Prelude.Strings.isInfixOf8_val
          pure (Cidr_Prelude.Strings.StrCons idr_Prelude.Strings.isInfixOf7_180 idr_Prelude.Strings.isInfixOf8_182) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr_Prelude.Strings.isInfixOf7_180 idr_Prelude.Strings.isInfixOf8_182)
      idr_Prelude.Strings.isInfixOf6_183 <- store idr_Prelude.Strings.isInfixOf6_val_161
      idr_Prelude.Strings.isInfixOf5_val_158 <- idr__Prelude.Strings.unpack_with_36 idr_Prelude.Strings.isInfixOf6_183
      idr_Prelude.Strings.isInfixOf5_184 <- store idr_Prelude.Strings.isInfixOf5_val_158
      pure (Cidr_Prelude.List.:: idr_Prelude.Strings.isInfixOf4_157 idr_Prelude.Strings.isInfixOf5_184) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr_Prelude.Strings.isInfixOf4_157 idr_Prelude.Strings.isInfixOf5_184)
  idr_Prelude.Strings.isInfixOf3_185 <- store idr_Prelude.Strings.isInfixOf3_val_142
  idr_PE_isInfixOf_22f242c8 idr_Prelude.Strings.isInfixOf2_141 idr_Prelude.Strings.isInfixOf3_185

idr_Prelude.List.isPrefixOfBy idr_Prelude.List.isPrefixOfBy1 idr_Prelude.List.isPrefixOfBy2 idr_Prelude.List.isPrefixOfBy3 =
  idr_Prelude.List.isPrefixOfBy2_val <- fetch idr_Prelude.List.isPrefixOfBy2
  case idr_Prelude.List.isPrefixOfBy2_val of
    (Cidr_Prelude.List.Nil) ->
      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
    #default ->
      idr_Prelude.List.isPrefixOfBy3_val <- fetch idr_Prelude.List.isPrefixOfBy3
      case idr_Prelude.List.isPrefixOfBy3_val of
        (Cidr_Prelude.List.:: idr_Prelude.List.isPrefixOfBy4 idr_Prelude.List.isPrefixOfBy5) ->
          idr_Prelude.List.isPrefixOfBy2_val_186 <- fetch idr_Prelude.List.isPrefixOfBy2
          (Cidr_Prelude.List.:: idr_Prelude.List.isPrefixOfBy6 idr_Prelude.List.isPrefixOfBy7) <- pure idr_Prelude.List.isPrefixOfBy2_val_186
          idr_Prelude.List.isPrefixOfBy8_val_187 <- do
            "idr_{APPLY_0}0.4" <- pure idr_Prelude.List.isPrefixOfBy1
            "idr_{APPLY_0}1.4" <- pure idr_Prelude.List.isPrefixOfBy6
            "idr_{APPLY_0}0_val.4" <- fetch "idr_{APPLY_0}0.4"
            case "idr_{APPLY_0}0_val.4" of
              (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.4" "idr_{APPLY_0}3.4" "idr_{APPLY_0}4.4") ->
                "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.4" "idr_{APPLY_0}3.4" "idr_{APPLY_0}4.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Data.Vect.{range_5}_1}") ->
                "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.4") ->
                idr_Main.processInput "idr_{APPLY_0}2_633.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.4") ->
                "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.{parse_3}_1}") ->
                "idr_Main.{parse_3}" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.4") ->
                "idr_Main.{search_10}" "idr_{APPLY_0}2_635.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.4" "idr_{APPLY_0}3_637.4") ->
                "idr_Main.{search_8}" "idr_{APPLY_0}2_636.4" "idr_{APPLY_0}3_637.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.{search_9}_1}") ->
                "idr_Main.{search_9}" "idr_{APPLY_0}1.4"
              (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.4" "idr_{APPLY_0}3_639.4" "idr_{APPLY_0}4_640.4" "idr_{APPLY_0}5.4") ->
                idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.4" "idr_{APPLY_0}4_640.4" "idr_{APPLY_0}5.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.4") ->
                "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.4"
              (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.4" "idr_{APPLY_0}3_643.4" "idr_{APPLY_0}4_644.4") ->
                "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.4" "idr_{APPLY_0}3_643.4" "idr_{APPLY_0}4_644.4"
              (C"idr_{U_prim__toStrBigInt_1}") ->
                idr_prim__toStrBigInt "idr_{APPLY_0}1.4"
              (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.4") ->
                "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.4" "idr_{APPLY_0}3_648.4") ->
                "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.4" "idr_{APPLY_0}3_648.4" "idr_{APPLY_0}1.4"
              (C"idr_{U_Main.processInput_2}") ->
                pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.4")
              (C"idr_{U_Main.{parseCommand_4}_2}") ->
                pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.4")
              (C"idr_{U_Main.{search_10}_2}") ->
                pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.4")
              (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.4") ->
                pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.4" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.4" "idr_{APPLY_0}1.4")
              (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
                pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.4")
              (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.4") ->
                pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.4" "idr_{APPLY_0}1.4") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.4" "idr_{APPLY_0}1.4")
              #default ->
                pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
          idr_Prelude.List.isPrefixOfBy8 <- store idr_Prelude.List.isPrefixOfBy8_val_187
          idr_Prelude.List.isPrefixOfBy8_val <- do
            "idr_{APPLY_0}0.5" <- pure idr_Prelude.List.isPrefixOfBy8
            "idr_{APPLY_0}1.5" <- pure idr_Prelude.List.isPrefixOfBy4
            "idr_{APPLY_0}0_val.5" <- fetch "idr_{APPLY_0}0.5"
            case "idr_{APPLY_0}0_val.5" of
              (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.5" "idr_{APPLY_0}3.5" "idr_{APPLY_0}4.5") ->
                "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.5" "idr_{APPLY_0}3.5" "idr_{APPLY_0}4.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Data.Vect.{range_5}_1}") ->
                "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.5") ->
                idr_Main.processInput "idr_{APPLY_0}2_633.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.5") ->
                "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.{parse_3}_1}") ->
                "idr_Main.{parse_3}" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.5") ->
                "idr_Main.{search_10}" "idr_{APPLY_0}2_635.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.5" "idr_{APPLY_0}3_637.5") ->
                "idr_Main.{search_8}" "idr_{APPLY_0}2_636.5" "idr_{APPLY_0}3_637.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.{search_9}_1}") ->
                "idr_Main.{search_9}" "idr_{APPLY_0}1.5"
              (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.5" "idr_{APPLY_0}3_639.5" "idr_{APPLY_0}4_640.5" "idr_{APPLY_0}5.5") ->
                idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.5" "idr_{APPLY_0}4_640.5" "idr_{APPLY_0}5.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.5") ->
                "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.5"
              (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.5" "idr_{APPLY_0}3_643.5" "idr_{APPLY_0}4_644.5") ->
                "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.5" "idr_{APPLY_0}3_643.5" "idr_{APPLY_0}4_644.5"
              (C"idr_{U_prim__toStrBigInt_1}") ->
                idr_prim__toStrBigInt "idr_{APPLY_0}1.5"
              (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.5") ->
                "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.5" "idr_{APPLY_0}3_648.5") ->
                "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.5" "idr_{APPLY_0}3_648.5" "idr_{APPLY_0}1.5"
              (C"idr_{U_Main.processInput_2}") ->
                pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.5")
              (C"idr_{U_Main.{parseCommand_4}_2}") ->
                pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.5")
              (C"idr_{U_Main.{search_10}_2}") ->
                pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.5")
              (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.5") ->
                pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.5" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.5" "idr_{APPLY_0}1.5")
              (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
                pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.5")
              (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.5") ->
                pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.5" "idr_{APPLY_0}1.5") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.5" "idr_{APPLY_0}1.5")
              #default ->
                pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
          idr_Prelude.List.isPrefixOfBy8_188 <- store idr_Prelude.List.isPrefixOfBy8_val
          idr_Prelude.List.isPrefixOfBy8_val_189 <- fetch idr_Prelude.List.isPrefixOfBy8_188
          case idr_Prelude.List.isPrefixOfBy8_val_189 of
            (Cidr_Prelude.Bool.False) ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
            (Cidr_Prelude.Bool.True) ->
              idr_Prelude.List.isPrefixOfBy9_val <- pure (CErased)
              idr_Prelude.List.isPrefixOfBy9 <- store idr_Prelude.List.isPrefixOfBy9_val
              idr_Prelude.List.isPrefixOfBy idr_Prelude.List.isPrefixOfBy1 idr_Prelude.List.isPrefixOfBy7 idr_Prelude.List.isPrefixOfBy5
        (Cidr_Prelude.List.Nil) ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)

idr_Data.Fin.natToFin idr_Data.Fin.natToFin0 idr_Data.Fin.natToFin1 =
  idr_Data.Fin.natToFin0_val <- fetch idr_Data.Fin.natToFin0
  case idr_Data.Fin.natToFin0_val of
    (CGrInt idr_Data.Fin.natToFin_cpat_LInt64_0) ->
      case idr_Data.Fin.natToFin_cpat_LInt64_0 of
        0 ->
          idr_Data.Fin.natToFin1_val <- fetch idr_Data.Fin.natToFin1
          case idr_Data.Fin.natToFin1_val of
            (CGrInt idr_Data.Fin.natToFin_cpat_LInt64_0_194) ->
              case idr_Data.Fin.natToFin_cpat_LInt64_0_194 of
                0 ->
                  pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
                #default ->
                  idr_Data.Fin.natToFin2_val_195 <- pure (CGrInt 1)
                  idr_Data.Fin.natToFin2 <- store idr_Data.Fin.natToFin2_val_195
                  idr_Data.Fin.natToFin2_val <- do
                    unboxed.CGrInt.17 <- do
                      (CGrInt idr_Data.Fin.natToFin1.32.19.arity.1) <- fetch idr_Data.Fin.natToFin1
                      (CGrInt idr_Data.Fin.natToFin2.32.19.arity.1) <- fetch idr_Data.Fin.natToFin2
                      idris_int_sub.unboxed idr_Data.Fin.natToFin1.32.19.arity.1 idr_Data.Fin.natToFin2.32.19.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin2.32.19.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin1.32.19.arity.1)
                    pure (CGrInt unboxed.CGrInt.17) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.17)
                  idr_Data.Fin.natToFin2_196 <- store idr_Data.Fin.natToFin2_val
                  idr_Data.Fin.natToFin3_val <- pure (Cidr_Data.Fin.FZ)
                  idr_Data.Fin.natToFin3 <- store idr_Data.Fin.natToFin3_val
                  pure (Cidr_Prelude.Maybe.Just idr_Data.Fin.natToFin3) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Data.Fin.natToFin3)
        #default ->
          idr_Data.Fin.natToFin2_val_204 <- pure (CGrInt 1)
          idr_Data.Fin.natToFin2_205 <- store idr_Data.Fin.natToFin2_val_204
          idr_Data.Fin.natToFin2_val_203 <- do
            unboxed.CGrInt.18 <- do
              (CGrInt idr_Data.Fin.natToFin0.32.20.arity.1) <- fetch idr_Data.Fin.natToFin0
              (CGrInt idr_Data.Fin.natToFin2_205.32.20.arity.1) <- fetch idr_Data.Fin.natToFin2_205
              idris_int_sub.unboxed idr_Data.Fin.natToFin0.32.20.arity.1 idr_Data.Fin.natToFin2_205.32.20.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin2_205.32.20.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin0.32.20.arity.1)
            pure (CGrInt unboxed.CGrInt.18) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.18)
          idr_Data.Fin.natToFin2_206 <- store idr_Data.Fin.natToFin2_val_203
          idr_Data.Fin.natToFin1_val_207 <- fetch idr_Data.Fin.natToFin1
          case idr_Data.Fin.natToFin1_val_207 of
            (CGrInt idr_Data.Fin.natToFin_cpat_LInt64_0_208) ->
              case idr_Data.Fin.natToFin_cpat_LInt64_0_208 of
                0 ->
                  pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
                #default ->
                  idr_Data.Fin.natToFin3_val_210 <- pure (CGrInt 1)
                  idr_Data.Fin.natToFin3_211 <- store idr_Data.Fin.natToFin3_val_210
                  idr_Data.Fin.natToFin3_val_209 <- do
                    unboxed.CGrInt.19 <- do
                      (CGrInt idr_Data.Fin.natToFin1.32.21.arity.1) <- fetch idr_Data.Fin.natToFin1
                      (CGrInt idr_Data.Fin.natToFin3_211.32.21.arity.1) <- fetch idr_Data.Fin.natToFin3_211
                      idris_int_sub.unboxed idr_Data.Fin.natToFin1.32.21.arity.1 idr_Data.Fin.natToFin3_211.32.21.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin3_211.32.21.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Fin.natToFin1.32.21.arity.1)
                    pure (CGrInt unboxed.CGrInt.19) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.19)
                  idr_Data.Fin.natToFin3_212 <- store idr_Data.Fin.natToFin3_val_209
                  idr_Data.Fin.natToFin4_val <- idr_Data.Fin.natToFin idr_Data.Fin.natToFin2_206 idr_Data.Fin.natToFin3_212
                  idr_Data.Fin.natToFin4 <- store idr_Data.Fin.natToFin4_val
                  idr_Data.Fin.natToFin4_val_213 <- fetch idr_Data.Fin.natToFin4
                  case idr_Data.Fin.natToFin4_val_213 of
                    (Cidr_Prelude.Maybe.Just idr_Data.Fin.natToFin5) ->
                      idr_Data.Fin.natToFin6_val <- pure (Cidr_Data.Fin.FS idr_Data.Fin.natToFin5)
                      idr_Data.Fin.natToFin6 <- store idr_Data.Fin.natToFin6_val
                      pure (Cidr_Prelude.Maybe.Just idr_Data.Fin.natToFin6) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Data.Fin.natToFin6)
                    (Cidr_Prelude.Maybe.Nothing) ->
                      pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)

idr_Main.parse idr_Main.parse0 =
  idr_Main.parse1_val_253 <- pure (CGrString #"")
  idr_Main.parse1 <- store idr_Main.parse1_val_253
  idr_Main.parse1_val_252 <- do
    unboxed.CGrInt.20 <- do
      (CGrString idr_Main.parse1.32.22.arity.1) <- fetch idr_Main.parse1
      idris_str_eq.unboxed idr_Main.parse0 idr_Main.parse1.32.22.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse1.32.22.arity.1)
    pure (CGrInt unboxed.CGrInt.20) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.20)
  idr_Main.parse1_254 <- store idr_Main.parse1_val_252
  idr_Main.parse1_val_255 <- fetch idr_Main.parse1_254
  idr_Main.parse1_val_251 <- case idr_Main.parse1_val_255 of
    (CGrInt idr_Main.parse_cpat_LInt64_0) ->
      case idr_Main.parse_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
  idr_Main.parse1_256 <- store idr_Main.parse1_val_251
  idr_Main.parse2_val <- pure (Cidr_Prelude.Bool.True)
  idr_Main.parse2 <- store idr_Main.parse2_val
  idr_Main.parse1_val_250 <- do
    (Cidr_Prelude.Bool.True) <- fetch idr_Main.parse2
    "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parse1_256 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
  idr_Main.parse1_257 <- store idr_Main.parse1_val_250
  idr_Main.parse1_val_258 <- fetch idr_Main.parse1_257
  idr_Main.parse1_val <- case idr_Main.parse1_val_258 of
    (Cidr_Prelude.Basics.No) ->
      idr_Main.parse2_val_259 <- pure (CGrString #"")
      idr_Main.parse2_260 <- store idr_Main.parse2_val_259
      idr_Main.parse3_val <- pure (CGrString #"")
      idr_Main.parse3 <- store idr_Main.parse3_val
      pure (Cidr_Builtins.MkPair idr_Main.parse2_260 idr_Main.parse3) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse2_260 idr_Main.parse3)
    (Cidr_Prelude.Basics.Yes) ->
      idr_Main.parse2_val_262 <- do
        unboxed.CGrInt.21 <- idris_str_head.unboxed idr_Main.parse0
        pure (CGrInt unboxed.CGrInt.21) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.21)
      idr_Main.parse2_263 <- store idr_Main.parse2_val_262
      idr_Main.parse3_val_264 <- pure (CGrInt 32)
      idr_Main.parse3_265 <- store idr_Main.parse3_val_264
      idr_Main.parse2_val_261 <- do
        unboxed.CGrInt.22 <- idris_int_eq.unboxed idr_Main.parse2_263 idr_Main.parse3_265
        pure (CGrInt unboxed.CGrInt.22) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.22)
      idr_Main.parse2_266 <- store idr_Main.parse2_val_261
      idr_Main.parse2_val_267 <- fetch idr_Main.parse2_266
      case idr_Main.parse2_val_267 of
        (CGrInt idr_Main.parse_cpat_LInt64_0_268) ->
          case idr_Main.parse_cpat_LInt64_0_268 of
            0 ->
              idr_Main.parse3_val_273 <- do
                unboxed.CGrString.19 <- idris_str_tail.unboxed idr_Main.parse0
                pure (CGrString unboxed.CGrString.19) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.19)
              idr_Main.parse3_274 <- store idr_Main.parse3_val_273
              idr_Main.parse4_val <- pure (CGrString #"")
              idr_Main.parse4 <- store idr_Main.parse4_val
              idr_Main.parse3_val_272 <- do
                unboxed.CGrInt.23 <- do
                  (CGrString idr_Main.parse4.32.24.arity.1) <- fetch idr_Main.parse4
                  idris_str_eq.unboxed idr_Main.parse3_274 idr_Main.parse4.32.24.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse4.32.24.arity.1)
                pure (CGrInt unboxed.CGrInt.23) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.23)
              idr_Main.parse3_275 <- store idr_Main.parse3_val_272
              idr_Main.parse3_val_276 <- fetch idr_Main.parse3_275
              idr_Main.parse3_val_271 <- case idr_Main.parse3_val_276 of
                (CGrInt idr_Main.parse_cpat_LInt64_0_277) ->
                  case idr_Main.parse_cpat_LInt64_0_277 of
                    0 ->
                      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                    #default ->
                      pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
              idr_Main.parse3_278 <- store idr_Main.parse3_val_271
              idr_Main.parse4_val_279 <- pure (Cidr_Prelude.Bool.True)
              idr_Main.parse4_280 <- store idr_Main.parse4_val_279
              idr_Main.parse3_val_270 <- do
                (Cidr_Prelude.Bool.True) <- fetch idr_Main.parse4_280
                "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parse3_278 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
              idr_Main.parse3_281 <- store idr_Main.parse3_val_270
              idr_Main.parse3_val_282 <- fetch idr_Main.parse3_281
              idr_Main.parse3_val_269 <- case idr_Main.parse3_val_282 of
                (Cidr_Prelude.Basics.No) ->
                  idr_Main.parse4_val_283 <- pure (CGrString #"")
                  idr_Main.parse4_284 <- store idr_Main.parse4_val_283
                  idr_Main.parse5_val <- pure (CGrString #"")
                  idr_Main.parse5 <- store idr_Main.parse5_val
                  pure (Cidr_Builtins.MkPair idr_Main.parse4_284 idr_Main.parse5) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse4_284 idr_Main.parse5)
                (Cidr_Prelude.Basics.Yes) ->
                  idr_Main.parse4_val_287 <- do
                    unboxed.CGrString.20 <- idris_str_tail.unboxed idr_Main.parse0
                    pure (CGrString unboxed.CGrString.20) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.20)
                  idr_Main.parse4_288 <- store idr_Main.parse4_val_287
                  idr_Main.parse4_val_286 <- do
                    unboxed.CGrInt.24 <- idris_str_head.unboxed idr_Main.parse4_288
                    pure (CGrInt unboxed.CGrInt.24) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.24)
                  idr_Main.parse4_289 <- store idr_Main.parse4_val_286
                  idr_Main.parse5_val_290 <- pure (CGrInt 32)
                  idr_Main.parse5_291 <- store idr_Main.parse5_val_290
                  idr_Main.parse4_val_285 <- do
                    unboxed.CGrInt.25 <- idris_int_eq.unboxed idr_Main.parse4_289 idr_Main.parse5_291
                    pure (CGrInt unboxed.CGrInt.25) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.25)
                  idr_Main.parse4_292 <- store idr_Main.parse4_val_285
                  idr_Main.parse4_val_293 <- fetch idr_Main.parse4_292
                  case idr_Main.parse4_val_293 of
                    (CGrInt idr_Main.parse_cpat_LInt64_0_294) ->
                      case idr_Main.parse_cpat_LInt64_0_294 of
                        0 ->
                          idr_Main.parse5_val_296 <- pure (C"idr_{U_Main.{parse_3}_1}")
                          idr_Main.parse5_297 <- store idr_Main.parse5_val_296
                          idr_Main.parse6_val <- pure (CErased)
                          idr_Main.parse6 <- store idr_Main.parse6_val
                          idr_Main.parse7_val_302 <- do
                            unboxed.CGrString.21 <- idris_str_tail.unboxed idr_Main.parse0
                            pure (CGrString unboxed.CGrString.21) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.21)
                          idr_Main.parse7 <- store idr_Main.parse7_val_302
                          idr_Main.parse7_val_301 <- do
                            unboxed.CGrString.22 <- idris_str_tail.unboxed idr_Main.parse7
                            pure (CGrString unboxed.CGrString.22) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.22)
                          idr_Main.parse7_303 <- store idr_Main.parse7_val_301
                          idr_Main.parse8_val <- pure (CGrString #"")
                          idr_Main.parse8 <- store idr_Main.parse8_val
                          idr_Main.parse7_val_300 <- do
                            unboxed.CGrInt.26 <- do
                              (CGrString idr_Main.parse8.32.26.arity.1) <- fetch idr_Main.parse8
                              idris_str_eq.unboxed idr_Main.parse7_303 idr_Main.parse8.32.26.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse8.32.26.arity.1)
                            pure (CGrInt unboxed.CGrInt.26) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.26)
                          idr_Main.parse7_304 <- store idr_Main.parse7_val_300
                          idr_Main.parse7_val_305 <- fetch idr_Main.parse7_304
                          idr_Main.parse7_val_299 <- case idr_Main.parse7_val_305 of
                            (CGrInt idr_Main.parse_cpat_LInt64_0_306) ->
                              case idr_Main.parse_cpat_LInt64_0_306 of
                                0 ->
                                  pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                                #default ->
                                  pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
                          idr_Main.parse7_307 <- store idr_Main.parse7_val_299
                          idr_Main.parse8_val_308 <- pure (Cidr_Prelude.Bool.True)
                          idr_Main.parse8_309 <- store idr_Main.parse8_val_308
                          idr_Main.parse7_val_298 <- do
                            (Cidr_Prelude.Bool.True) <- fetch idr_Main.parse8_309
                            "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parse7_307 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
                          idr_Main.parse7_310 <- store idr_Main.parse7_val_298
                          idr_Main.parse7_val_311 <- fetch idr_Main.parse7_310
                          idr_Main.parse7_val <- case idr_Main.parse7_val_311 of
                            (Cidr_Prelude.Basics.No) ->
                              pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
                            (Cidr_Prelude.Basics.Yes) ->
                              idr_Main.parse8_val_314 <- do
                                unboxed.CGrString.23 <- idris_str_tail.unboxed idr_Main.parse0
                                pure (CGrString unboxed.CGrString.23) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.23)
                              idr_Main.parse8_315 <- store idr_Main.parse8_val_314
                              idr_Main.parse8_val_313 <- do
                                unboxed.CGrString.24 <- idris_str_tail.unboxed idr_Main.parse8_315
                                pure (CGrString unboxed.CGrString.24) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.24)
                              idr_Main.parse8_316 <- store idr_Main.parse8_val_313
                              idr_Main.parse8_val_312 <- do
                                unboxed.CGrInt.27 <- idris_str_head.unboxed idr_Main.parse8_316
                                pure (CGrInt unboxed.CGrInt.27) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.27)
                              idr_Main.parse8_317 <- store idr_Main.parse8_val_312
                              idr_Main.parse9_val_319 <- do
                                unboxed.CGrString.25 <- idris_str_tail.unboxed idr_Main.parse0
                                pure (CGrString unboxed.CGrString.25) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.25)
                              idr_Main.parse9 <- store idr_Main.parse9_val_319
                              idr_Main.parse9_val_318 <- do
                                unboxed.CGrString.26 <- idris_str_tail.unboxed idr_Main.parse9
                                pure (CGrString unboxed.CGrString.26) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.26)
                              idr_Main.parse9_320 <- store idr_Main.parse9_val_318
                              idr_Main.parse9_val <- do
                                unboxed.CGrString.27 <- idris_str_tail.unboxed idr_Main.parse9_320
                                pure (CGrString unboxed.CGrString.27) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.27)
                              idr_Main.parse9_321 <- store idr_Main.parse9_val
                              pure (Cidr_Prelude.Strings.StrCons idr_Main.parse8_317 idr_Main.parse9_321) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr_Main.parse8_317 idr_Main.parse9_321)
                          idr_Main.parse7_322 <- store idr_Main.parse7_val
                          idr_Main.parse5_val_295 <- idr__Prelude.Strings.span_with_50 idr_Main.parse5_297 idr_Main.parse7_322
                          idr_Main.parse5_323 <- store idr_Main.parse5_val_295
                          idr_Main.parse5_val_324 <- fetch idr_Main.parse5_323
                          (Cidr_Builtins.MkPair idr_Main.parse6_325 idr_Main.parse7_326) <- pure idr_Main.parse5_val_324
                          idr_Main.parse8_val_329 <- do
                            unboxed.CGrString.28 <- idris_str_tail.unboxed idr_Main.parse0
                            pure (CGrString unboxed.CGrString.28) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.28)
                          idr_Main.parse8_330 <- store idr_Main.parse8_val_329
                          idr_Main.parse8_val_328 <- do
                            unboxed.CGrInt.28 <- idris_str_head.unboxed idr_Main.parse8_330
                            pure (CGrInt unboxed.CGrInt.28) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.28)
                          idr_Main.parse8_331 <- store idr_Main.parse8_val_328
                          idr_Main.parse8_val_327 <- do
                            unboxed.CGrString.29 <- do
                              (CGrInt idr_Main.parse8_331.32.28.arity.1) <- fetch idr_Main.parse8_331
                              (CGrString idr_Main.parse6_325.32.28.arity.1) <- fetch idr_Main.parse6_325
                              idris_str_cons.unboxed idr_Main.parse8_331.32.28.arity.1 idr_Main.parse6_325.32.28.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse6_325.32.28.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.parse8_331.32.28.arity.1)
                            pure (CGrString unboxed.CGrString.29) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.29)
                          idr_Main.parse8_332 <- store idr_Main.parse8_val_327
                          pure (Cidr_Builtins.MkPair idr_Main.parse8_332 idr_Main.parse7_326) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse8_332 idr_Main.parse7_326)
                        #default ->
                          idr_Main.parse5_val_333 <- pure (CGrString #"")
                          idr_Main.parse5_334 <- store idr_Main.parse5_val_333
                          idr_Main.parse6_val_337 <- do
                            unboxed.CGrString.30 <- idris_str_tail.unboxed idr_Main.parse0
                            pure (CGrString unboxed.CGrString.30) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.30)
                          idr_Main.parse6_338 <- store idr_Main.parse6_val_337
                          idr_Main.parse6_val_336 <- do
                            unboxed.CGrInt.29 <- idris_str_head.unboxed idr_Main.parse6_338
                            pure (CGrInt unboxed.CGrInt.29) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.29)
                          idr_Main.parse6_339 <- store idr_Main.parse6_val_336
                          idr_Main.parse7_val_341 <- do
                            unboxed.CGrString.31 <- idris_str_tail.unboxed idr_Main.parse0
                            pure (CGrString unboxed.CGrString.31) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.31)
                          idr_Main.parse7_342 <- store idr_Main.parse7_val_341
                          idr_Main.parse7_val_340 <- do
                            unboxed.CGrString.32 <- idris_str_tail.unboxed idr_Main.parse7_342
                            pure (CGrString unboxed.CGrString.32) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.32)
                          idr_Main.parse7_343 <- store idr_Main.parse7_val_340
                          idr_Main.parse6_val_335 <- do
                            unboxed.CGrString.33 <- do
                              (CGrInt idr_Main.parse6_339.32.29.arity.1) <- fetch idr_Main.parse6_339
                              (CGrString idr_Main.parse7_343.32.29.arity.1) <- fetch idr_Main.parse7_343
                              idris_str_cons.unboxed idr_Main.parse6_339.32.29.arity.1 idr_Main.parse7_343.32.29.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse7_343.32.29.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.parse6_339.32.29.arity.1)
                            pure (CGrString unboxed.CGrString.33) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.33)
                          idr_Main.parse6_344 <- store idr_Main.parse6_val_335
                          pure (Cidr_Builtins.MkPair idr_Main.parse5_334 idr_Main.parse6_344) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse5_334 idr_Main.parse6_344)
              idr_Main.parse3_357 <- store idr_Main.parse3_val_269
              idr_Main.parse3_val_358 <- fetch idr_Main.parse3_357
              (Cidr_Builtins.MkPair idr_Main.parse4_359 idr_Main.parse5_360) <- pure idr_Main.parse3_val_358
              idr_Main.parse6_val_362 <- do
                unboxed.CGrInt.30 <- idris_str_head.unboxed idr_Main.parse0
                pure (CGrInt unboxed.CGrInt.30) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.30)
              idr_Main.parse6_363 <- store idr_Main.parse6_val_362
              idr_Main.parse6_val_361 <- do
                unboxed.CGrString.34 <- do
                  (CGrInt idr_Main.parse6_363.32.30.arity.1) <- fetch idr_Main.parse6_363
                  (CGrString idr_Main.parse4_359.32.30.arity.1) <- fetch idr_Main.parse4_359
                  idris_str_cons.unboxed idr_Main.parse6_363.32.30.arity.1 idr_Main.parse4_359.32.30.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse4_359.32.30.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.parse6_363.32.30.arity.1)
                pure (CGrString unboxed.CGrString.34) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.34)
              idr_Main.parse6_364 <- store idr_Main.parse6_val_361
              pure (Cidr_Builtins.MkPair idr_Main.parse6_364 idr_Main.parse5_360) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse6_364 idr_Main.parse5_360)
            #default ->
              idr_Main.parse3_val_365 <- pure (CGrString #"")
              idr_Main.parse3_366 <- store idr_Main.parse3_val_365
              idr_Main.parse4_val_368 <- do
                unboxed.CGrInt.31 <- idris_str_head.unboxed idr_Main.parse0
                pure (CGrInt unboxed.CGrInt.31) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.31)
              idr_Main.parse4_369 <- store idr_Main.parse4_val_368
              idr_Main.parse5_val_370 <- do
                unboxed.CGrString.35 <- idris_str_tail.unboxed idr_Main.parse0
                pure (CGrString unboxed.CGrString.35) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.35)
              idr_Main.parse5_371 <- store idr_Main.parse5_val_370
              idr_Main.parse4_val_367 <- do
                unboxed.CGrString.36 <- do
                  (CGrInt idr_Main.parse4_369.32.31.arity.1) <- fetch idr_Main.parse4_369
                  (CGrString idr_Main.parse5_371.32.31.arity.1) <- fetch idr_Main.parse5_371
                  idris_str_cons.unboxed idr_Main.parse4_369.32.31.arity.1 idr_Main.parse5_371.32.31.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse5_371.32.31.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.parse4_369.32.31.arity.1)
                pure (CGrString unboxed.CGrString.36) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.36)
              idr_Main.parse4_372 <- store idr_Main.parse4_val_367
              pure (Cidr_Builtins.MkPair idr_Main.parse3_366 idr_Main.parse4_372) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr_Main.parse3_366 idr_Main.parse4_372)
  idr_Main.parse1_381 <- store idr_Main.parse1_val
  idr_Main.parse1_val_382 <- fetch idr_Main.parse1_381
  (Cidr_Builtins.MkPair idr_Main.parse2_383 idr_Main.parse3_384) <- pure idr_Main.parse1_val_382
  do
    (CGrString idr_Main.parse2_383.32.32.arity.1) <- fetch idr_Main.parse2_383
    idr_Main.parseCommand idr_Main.parse2_383.32.32.arity.1 idr_Main.parse3_384 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parse2_383.32.32.arity.1)

idr_Main.parseCommand idr_Main.parseCommand0.32.arity.1 idr_Main.parseCommand1 =
  idr_Main.parseCommand0_val <- pure (CGrString idr_Main.parseCommand0.32.arity.1)
  case idr_Main.parseCommand0_val of
    (CGrString "idr_Main.parseCommand_cpat_LString_\"add\"") ->
      case "idr_Main.parseCommand_cpat_LString_\"add\"" of
        #"add" ->
          idr_Main.parseCommand2_val <- pure (Cidr_Main.Add idr_Main.parseCommand1)
          idr_Main.parseCommand2 <- store idr_Main.parseCommand2_val
          pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2)
        #"get" ->
          idr_Main.parseCommand2_val_386 <- pure (CErased)
          idr_Main.parseCommand2_387 <- store idr_Main.parseCommand2_val_386
          idr_Main.parseCommand3_val <- pure (CErased)
          idr_Main.parseCommand3 <- store idr_Main.parseCommand3_val
          idr_Main.parseCommand4_val <- pure (C"idr_{U_Main.{parseCommand_4}_2}")
          idr_Main.parseCommand4 <- store idr_Main.parseCommand4_val
          idr_Main.parseCommand5_val <- pure (Cidr_Prelude.Bool.True)
          idr_Main.parseCommand5 <- store idr_Main.parseCommand5_val
          idr_Main.parseCommand6_val_391 <- pure (CGrString #"")
          idr_Main.parseCommand6 <- store idr_Main.parseCommand6_val_391
          idr_Main.parseCommand6_val_390 <- do
            unboxed.CGrInt.32 <- do
              (CGrString idr_Main.parseCommand6.32.33.arity.1) <- fetch idr_Main.parseCommand6
              idris_str_eq.unboxed idr_Main.parseCommand1 idr_Main.parseCommand6.32.33.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parseCommand6.32.33.arity.1)
            pure (CGrInt unboxed.CGrInt.32) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.32)
          idr_Main.parseCommand6_392 <- store idr_Main.parseCommand6_val_390
          idr_Main.parseCommand6_val_393 <- fetch idr_Main.parseCommand6_392
          idr_Main.parseCommand6_val_389 <- case idr_Main.parseCommand6_val_393 of
            (CGrInt idr_Main.parseCommand_cpat_LInt64_0) ->
              case idr_Main.parseCommand_cpat_LInt64_0 of
                0 ->
                  pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                #default ->
                  pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
          idr_Main.parseCommand6_394 <- store idr_Main.parseCommand6_val_389
          idr_Main.parseCommand7_val <- pure (Cidr_Prelude.Bool.True)
          idr_Main.parseCommand7 <- store idr_Main.parseCommand7_val
          idr_Main.parseCommand6_val_388 <- do
            (Cidr_Prelude.Bool.True) <- fetch idr_Main.parseCommand7
            "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parseCommand6_394 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
          idr_Main.parseCommand6_395 <- store idr_Main.parseCommand6_val_388
          idr_Main.parseCommand6_val_396 <- fetch idr_Main.parseCommand6_395
          idr_Main.parseCommand6_val <- case idr_Main.parseCommand6_val_396 of
            (Cidr_Prelude.Basics.No) ->
              pure (Cidr_Prelude.List.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.Nil)
            (Cidr_Prelude.Basics.Yes) ->
              idr_Main.parseCommand7_val_397 <- do
                unboxed.CGrInt.33 <- idris_str_head.unboxed idr_Main.parseCommand1
                pure (CGrInt unboxed.CGrInt.33) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.33)
              idr_Main.parseCommand7_398 <- store idr_Main.parseCommand7_val_397
              idr_Main.parseCommand8_val_402 <- do
                unboxed.CGrString.37 <- idris_str_tail.unboxed idr_Main.parseCommand1
                pure (CGrString unboxed.CGrString.37) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.37)
              idr_Main.parseCommand8 <- store idr_Main.parseCommand8_val_402
              idr_Main.parseCommand9_val <- pure (CGrString #"")
              idr_Main.parseCommand9 <- store idr_Main.parseCommand9_val
              idr_Main.parseCommand8_val_401 <- do
                unboxed.CGrInt.34 <- do
                  (CGrString idr_Main.parseCommand9.32.35.arity.1) <- fetch idr_Main.parseCommand9
                  idris_str_eq.unboxed idr_Main.parseCommand8 idr_Main.parseCommand9.32.35.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parseCommand9.32.35.arity.1)
                pure (CGrInt unboxed.CGrInt.34) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.34)
              idr_Main.parseCommand8_403 <- store idr_Main.parseCommand8_val_401
              idr_Main.parseCommand8_val_404 <- fetch idr_Main.parseCommand8_403
              idr_Main.parseCommand8_val_400 <- case idr_Main.parseCommand8_val_404 of
                (CGrInt idr_Main.parseCommand_cpat_LInt64_0_405) ->
                  case idr_Main.parseCommand_cpat_LInt64_0_405 of
                    0 ->
                      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                    #default ->
                      pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
              idr_Main.parseCommand8_406 <- store idr_Main.parseCommand8_val_400
              idr_Main.parseCommand9_val_407 <- pure (Cidr_Prelude.Bool.True)
              idr_Main.parseCommand9_408 <- store idr_Main.parseCommand9_val_407
              idr_Main.parseCommand8_val_399 <- do
                (Cidr_Prelude.Bool.True) <- fetch idr_Main.parseCommand9_408
                "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parseCommand8_406 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
              idr_Main.parseCommand8_409 <- store idr_Main.parseCommand8_val_399
              idr_Main.parseCommand8_val_410 <- fetch idr_Main.parseCommand8_409
              idr_Main.parseCommand8_val <- case idr_Main.parseCommand8_val_410 of
                (Cidr_Prelude.Basics.No) ->
                  pure (Cidr_Prelude.List.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.Nil)
                (Cidr_Prelude.Basics.Yes) ->
                  idr_Main.parseCommand9_val_412 <- do
                    unboxed.CGrString.38 <- idris_str_tail.unboxed idr_Main.parseCommand1
                    pure (CGrString unboxed.CGrString.38) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.38)
                  idr_Main.parseCommand9_413 <- store idr_Main.parseCommand9_val_412
                  idr_Main.parseCommand9_val_411 <- do
                    unboxed.CGrInt.35 <- idris_str_head.unboxed idr_Main.parseCommand9_413
                    pure (CGrInt unboxed.CGrInt.35) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.35)
                  idr_Main.parseCommand9_414 <- store idr_Main.parseCommand9_val_411
                  idr_Main.parseCommand10_val_415 <- pure (CErased)
                  idr_Main.parseCommand10 <- store idr_Main.parseCommand10_val_415
                  idr_Main.parseCommand11_val_420 <- do
                    unboxed.CGrString.39 <- idris_str_tail.unboxed idr_Main.parseCommand1
                    pure (CGrString unboxed.CGrString.39) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.39)
                  idr_Main.parseCommand11 <- store idr_Main.parseCommand11_val_420
                  idr_Main.parseCommand11_val_419 <- do
                    unboxed.CGrString.40 <- idris_str_tail.unboxed idr_Main.parseCommand11
                    pure (CGrString unboxed.CGrString.40) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.40)
                  idr_Main.parseCommand11_421 <- store idr_Main.parseCommand11_val_419
                  idr_Main.parseCommand12_val <- pure (CGrString #"")
                  idr_Main.parseCommand12 <- store idr_Main.parseCommand12_val
                  idr_Main.parseCommand11_val_418 <- do
                    unboxed.CGrInt.36 <- do
                      (CGrString idr_Main.parseCommand12.32.37.arity.1) <- fetch idr_Main.parseCommand12
                      idris_str_eq.unboxed idr_Main.parseCommand11_421 idr_Main.parseCommand12.32.37.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parseCommand12.32.37.arity.1)
                    pure (CGrInt unboxed.CGrInt.36) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.36)
                  idr_Main.parseCommand11_422 <- store idr_Main.parseCommand11_val_418
                  idr_Main.parseCommand11_val_423 <- fetch idr_Main.parseCommand11_422
                  idr_Main.parseCommand11_val_417 <- case idr_Main.parseCommand11_val_423 of
                    (CGrInt idr_Main.parseCommand_cpat_LInt64_0_424) ->
                      case idr_Main.parseCommand_cpat_LInt64_0_424 of
                        0 ->
                          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                        #default ->
                          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
                  idr_Main.parseCommand11_425 <- store idr_Main.parseCommand11_val_417
                  idr_Main.parseCommand12_val_426 <- pure (Cidr_Prelude.Bool.True)
                  idr_Main.parseCommand12_427 <- store idr_Main.parseCommand12_val_426
                  idr_Main.parseCommand11_val_416 <- do
                    (Cidr_Prelude.Bool.True) <- fetch idr_Main.parseCommand12_427
                    "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Main.parseCommand11_425 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
                  idr_Main.parseCommand11_428 <- store idr_Main.parseCommand11_val_416
                  idr_Main.parseCommand11_val_429 <- fetch idr_Main.parseCommand11_428
                  idr_Main.parseCommand11_val <- case idr_Main.parseCommand11_val_429 of
                    (Cidr_Prelude.Basics.No) ->
                      pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
                    (Cidr_Prelude.Basics.Yes) ->
                      idr_Main.parseCommand12_val_432 <- do
                        unboxed.CGrString.41 <- idris_str_tail.unboxed idr_Main.parseCommand1
                        pure (CGrString unboxed.CGrString.41) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.41)
                      idr_Main.parseCommand12_433 <- store idr_Main.parseCommand12_val_432
                      idr_Main.parseCommand12_val_431 <- do
                        unboxed.CGrString.42 <- idris_str_tail.unboxed idr_Main.parseCommand12_433
                        pure (CGrString unboxed.CGrString.42) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.42)
                      idr_Main.parseCommand12_434 <- store idr_Main.parseCommand12_val_431
                      idr_Main.parseCommand12_val_430 <- do
                        unboxed.CGrInt.37 <- idris_str_head.unboxed idr_Main.parseCommand12_434
                        pure (CGrInt unboxed.CGrInt.37) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.37)
                      idr_Main.parseCommand12_435 <- store idr_Main.parseCommand12_val_430
                      idr_Main.parseCommand13_val_437 <- do
                        unboxed.CGrString.43 <- idris_str_tail.unboxed idr_Main.parseCommand1
                        pure (CGrString unboxed.CGrString.43) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.43)
                      idr_Main.parseCommand13 <- store idr_Main.parseCommand13_val_437
                      idr_Main.parseCommand13_val_436 <- do
                        unboxed.CGrString.44 <- idris_str_tail.unboxed idr_Main.parseCommand13
                        pure (CGrString unboxed.CGrString.44) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.44)
                      idr_Main.parseCommand13_438 <- store idr_Main.parseCommand13_val_436
                      idr_Main.parseCommand13_val <- do
                        unboxed.CGrString.45 <- idris_str_tail.unboxed idr_Main.parseCommand13_438
                        pure (CGrString unboxed.CGrString.45) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.45)
                      idr_Main.parseCommand13_439 <- store idr_Main.parseCommand13_val
                      pure (Cidr_Prelude.Strings.StrCons idr_Main.parseCommand12_435 idr_Main.parseCommand13_439) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr_Main.parseCommand12_435 idr_Main.parseCommand13_439)
                  idr_Main.parseCommand11_440 <- store idr_Main.parseCommand11_val
                  idr_Main.parseCommand10_val <- idr__Prelude.Strings.unpack_with_36 idr_Main.parseCommand11_440
                  idr_Main.parseCommand10_441 <- store idr_Main.parseCommand10_val
                  pure (Cidr_Prelude.List.:: idr_Main.parseCommand9_414 idr_Main.parseCommand10_441) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr_Main.parseCommand9_414 idr_Main.parseCommand10_441)
              idr_Main.parseCommand8_442 <- store idr_Main.parseCommand8_val
              pure (Cidr_Prelude.List.:: idr_Main.parseCommand7_398 idr_Main.parseCommand8_442) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr_Main.parseCommand7_398 idr_Main.parseCommand8_442)
          idr_Main.parseCommand6_443 <- store idr_Main.parseCommand6_val
          idr_Main.parseCommand2_val_385 <- "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:0" idr_Main.parseCommand4 idr_Main.parseCommand5 idr_Main.parseCommand6_443
          idr_Main.parseCommand2_444 <- store idr_Main.parseCommand2_val_385
          idr_Main.parseCommand2_val_445 <- fetch idr_Main.parseCommand2_444
          case idr_Main.parseCommand2_val_445 of
            (Cidr_Prelude.Bool.False) ->
              pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
            (Cidr_Prelude.Bool.True) ->
              idr_Main.parseCommand3_val_447 <- do
                unboxed.CGrInt.38 <- do
                  (CGrString idr_Main.parseCommand1.32.39.arity.1) <- fetch idr_Main.parseCommand1
                  idris_str_int.unboxed idr_Main.parseCommand1.32.39.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Main.parseCommand1.32.39.arity.1)
                pure (CGrInt unboxed.CGrInt.38) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.38)
              idr_Main.parseCommand3_448 <- store idr_Main.parseCommand3_val_447
              idr_Main.parseCommand3_val_446 <- pure (Cidr_Main.Get idr_Main.parseCommand3_448)
              idr_Main.parseCommand3_449 <- store idr_Main.parseCommand3_val_446
              pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand3_449) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand3_449)
        #"quit" ->
          idr_Main.parseCommand1_val <- fetch idr_Main.parseCommand1
          case idr_Main.parseCommand1_val of
            (CGrString "idr_Main.parseCommand_cpat_LString_\"\"") ->
              case "idr_Main.parseCommand_cpat_LString_\"\"" of
                #"" ->
                  idr_Main.parseCommand2_val_450 <- pure (Cidr_Main.Quit)
                  idr_Main.parseCommand2_451 <- store idr_Main.parseCommand2_val_450
                  pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_451) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_451)
                #default ->
                  pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
        #"search" ->
          idr_Main.parseCommand2_val_452 <- pure (Cidr_Main.Search idr_Main.parseCommand1)
          idr_Main.parseCommand2_453 <- store idr_Main.parseCommand2_val_452
          pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_453) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_453)
        #"size" ->
          idr_Main.parseCommand1_val_454 <- fetch idr_Main.parseCommand1
          case idr_Main.parseCommand1_val_454 of
            (CGrString "idr_Main.parseCommand_cpat_LString_\"\"_455") ->
              case "idr_Main.parseCommand_cpat_LString_\"\"_455" of
                #"" ->
                  idr_Main.parseCommand2_val_456 <- pure (Cidr_Main.Size)
                  idr_Main.parseCommand2_457 <- store idr_Main.parseCommand2_val_456
                  pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_457) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.parseCommand2_457)
                #default ->
                  pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
        #default ->
          pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)

idr_Prelude.Show.primNumShow idr_Prelude.Show.primNumShow1 idr_Prelude.Show.primNumShow3 =
  idr_Prelude.Show.primNumShow4_val <- do
    "idr_{APPLY_0}0.6" <- pure idr_Prelude.Show.primNumShow1
    "idr_{APPLY_0}1.6" <- pure idr_Prelude.Show.primNumShow3
    "idr_{APPLY_0}0_val.6" <- fetch "idr_{APPLY_0}0.6"
    case "idr_{APPLY_0}0_val.6" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.6" "idr_{APPLY_0}3.6" "idr_{APPLY_0}4.6") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.6" "idr_{APPLY_0}3.6" "idr_{APPLY_0}4.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.6") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.6") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.6") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.6" "idr_{APPLY_0}3_637.6") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.6" "idr_{APPLY_0}3_637.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.6"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.6" "idr_{APPLY_0}3_639.6" "idr_{APPLY_0}4_640.6" "idr_{APPLY_0}5.6") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.6" "idr_{APPLY_0}4_640.6" "idr_{APPLY_0}5.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.6") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.6"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.6" "idr_{APPLY_0}3_643.6" "idr_{APPLY_0}4_644.6") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.6" "idr_{APPLY_0}3_643.6" "idr_{APPLY_0}4_644.6"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.6"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.6") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.6" "idr_{APPLY_0}3_648.6") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.6" "idr_{APPLY_0}3_648.6" "idr_{APPLY_0}1.6"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.6")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.6")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.6")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.6") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.6" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.6" "idr_{APPLY_0}1.6")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.6")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.6") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.6" "idr_{APPLY_0}1.6") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.6" "idr_{APPLY_0}1.6")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
  idr_Prelude.Show.primNumShow4 <- store idr_Prelude.Show.primNumShow4_val
  idr_Prelude.Show.primNumShow2_val <- pure (Cidr_Prelude.Show.Open)
  ccp.4 <- case idr_Prelude.Show.primNumShow2_val of
    (Cidr_Prelude.Show.Open) ->
      pure 0
  idr_Prelude.Show.primNumShow5_val_460 <- pure (CGrInt ccp.4)
  idr_Prelude.Show.primNumShow5 <- store idr_Prelude.Show.primNumShow5_val_460
  idr_Prelude.Show.primNumShow6_val <- pure (CGrInt 5)
  idr_Prelude.Show.primNumShow6 <- store idr_Prelude.Show.primNumShow6_val
  idr_Prelude.Show.primNumShow5_val_459 <- "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0" idr_Prelude.Show.primNumShow5 idr_Prelude.Show.primNumShow6
  idr_Prelude.Show.primNumShow5_461 <- store idr_Prelude.Show.primNumShow5_val_459
  idr_Prelude.Show.primNumShow5_val_462 <- fetch idr_Prelude.Show.primNumShow5_461
  idr_Prelude.Show.primNumShow5_val_458 <- case idr_Prelude.Show.primNumShow5_val_462 of
    (Cidr_Prelude.Interfaces.GT) ->
      pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
    #default ->
      idr_Prelude.Show.primNumShow2_val_465 <- pure (Cidr_Prelude.Show.Open)
      ccp.5 <- case idr_Prelude.Show.primNumShow2_val_465 of
        (Cidr_Prelude.Show.Open) ->
          pure 0
      idr_Prelude.Show.primNumShow6_val_464 <- pure (CGrInt ccp.5)
      idr_Prelude.Show.primNumShow6_466 <- store idr_Prelude.Show.primNumShow6_val_464
      idr_Prelude.Show.primNumShow7_val <- pure (CGrInt 5)
      idr_Prelude.Show.primNumShow7 <- store idr_Prelude.Show.primNumShow7_val
      idr_Prelude.Show.primNumShow6_val_463 <- do
        unboxed.CGrInt.39 <- idris_int_eq.unboxed idr_Prelude.Show.primNumShow6_466 idr_Prelude.Show.primNumShow7
        pure (CGrInt unboxed.CGrInt.39) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.39)
      idr_Prelude.Show.primNumShow6_467 <- store idr_Prelude.Show.primNumShow6_val_463
      idr_Prelude.Show.primNumShow6_val_468 <- fetch idr_Prelude.Show.primNumShow6_467
      case idr_Prelude.Show.primNumShow6_val_468 of
        (CGrInt idr_Prelude.Show.primNumShow_cpat_LInt64_0) ->
          case idr_Prelude.Show.primNumShow_cpat_LInt64_0 of
            0 ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
            #default ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Show.primNumShow5_469 <- store idr_Prelude.Show.primNumShow5_val_458
  idr_Prelude.Show.primNumShow5_val_470 <- fetch idr_Prelude.Show.primNumShow5_469
  idr_Prelude.Show.primNumShow5_val <- case idr_Prelude.Show.primNumShow5_val_470 of
    (Cidr_Prelude.Bool.False) ->
      pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
    (Cidr_Prelude.Bool.True) ->
      idr_Prelude.Show.primNumShow6_val_474 <- pure (CGrString #"")
      idr_Prelude.Show.primNumShow6_475 <- store idr_Prelude.Show.primNumShow6_val_474
      idr_Prelude.Show.primNumShow6_val_473 <- do
        unboxed.CGrInt.40 <- do
          (CGrString idr_Prelude.Show.primNumShow6_475.32.40.arity.1) <- fetch idr_Prelude.Show.primNumShow6_475
          idris_str_eq.unboxed idr_Prelude.Show.primNumShow4 idr_Prelude.Show.primNumShow6_475.32.40.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr_Prelude.Show.primNumShow6_475.32.40.arity.1)
        pure (CGrInt unboxed.CGrInt.40) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.40)
      idr_Prelude.Show.primNumShow6_476 <- store idr_Prelude.Show.primNumShow6_val_473
      idr_Prelude.Show.primNumShow6_val_477 <- fetch idr_Prelude.Show.primNumShow6_476
      idr_Prelude.Show.primNumShow6_val_472 <- case idr_Prelude.Show.primNumShow6_val_477 of
        (CGrInt idr_Prelude.Show.primNumShow_cpat_LInt64_0_478) ->
          case idr_Prelude.Show.primNumShow_cpat_LInt64_0_478 of
            0 ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
            #default ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
      idr_Prelude.Show.primNumShow6_479 <- store idr_Prelude.Show.primNumShow6_val_472
      idr_Prelude.Show.primNumShow7_val_480 <- pure (Cidr_Prelude.Bool.True)
      idr_Prelude.Show.primNumShow7_481 <- store idr_Prelude.Show.primNumShow7_val_480
      idr_Prelude.Show.primNumShow6_val_471 <- do
        (Cidr_Prelude.Bool.True) <- fetch idr_Prelude.Show.primNumShow7_481
        "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr_Prelude.Show.primNumShow6_479 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
      idr_Prelude.Show.primNumShow6_482 <- store idr_Prelude.Show.primNumShow6_val_471
      idr_Prelude.Show.primNumShow6_val_483 <- fetch idr_Prelude.Show.primNumShow6_482
      case idr_Prelude.Show.primNumShow6_val_483 of
        (Cidr_Prelude.Basics.No) ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
        (Cidr_Prelude.Basics.Yes) ->
          idr_Prelude.Show.primNumShow7_val_485 <- do
            unboxed.CGrInt.41 <- idris_str_head.unboxed idr_Prelude.Show.primNumShow4
            pure (CGrInt unboxed.CGrInt.41) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.41)
          idr_Prelude.Show.primNumShow7_486 <- store idr_Prelude.Show.primNumShow7_val_485
          idr_Prelude.Show.primNumShow8_val <- pure (CGrInt 45)
          idr_Prelude.Show.primNumShow8 <- store idr_Prelude.Show.primNumShow8_val
          idr_Prelude.Show.primNumShow7_val_484 <- do
            unboxed.CGrInt.42 <- idris_int_eq.unboxed idr_Prelude.Show.primNumShow7_486 idr_Prelude.Show.primNumShow8
            pure (CGrInt unboxed.CGrInt.42) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.42)
          idr_Prelude.Show.primNumShow7_487 <- store idr_Prelude.Show.primNumShow7_val_484
          idr_Prelude.Show.primNumShow7_val_488 <- fetch idr_Prelude.Show.primNumShow7_487
          case idr_Prelude.Show.primNumShow7_val_488 of
            (CGrInt idr_Prelude.Show.primNumShow_cpat_LInt64_0_489) ->
              case idr_Prelude.Show.primNumShow_cpat_LInt64_0_489 of
                0 ->
                  pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
                #default ->
                  pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
  idr_Prelude.Show.primNumShow5_490 <- store idr_Prelude.Show.primNumShow5_val
  idr_Prelude.Show.primNumShow5_val_491 <- fetch idr_Prelude.Show.primNumShow5_490
  case idr_Prelude.Show.primNumShow5_val_491 of
    (Cidr_Prelude.Bool.False) ->
      fetch idr_Prelude.Show.primNumShow4
    (Cidr_Prelude.Bool.True) ->
      idr_Prelude.Show.primNumShow6_val_492 <- pure (CGrString #"(")
      idr_Prelude.Show.primNumShow6_493 <- store idr_Prelude.Show.primNumShow6_val_492
      idr_Prelude.Show.primNumShow7_val_495 <- pure (CGrString #")")
      idr_Prelude.Show.primNumShow7_496 <- store idr_Prelude.Show.primNumShow7_val_495
      idr_Prelude.Show.primNumShow7_val_494 <- idris_str_concat idr_Prelude.Show.primNumShow4 idr_Prelude.Show.primNumShow7_496
      idr_Prelude.Show.primNumShow7_497 <- store idr_Prelude.Show.primNumShow7_val_494
      idris_str_concat idr_Prelude.Show.primNumShow6_493 idr_Prelude.Show.primNumShow7_497

idr_prim__stdin.unboxed =
  prim__stdin.unboxed

idr_prim__toStrBigInt idr_prim__toStrBigInt0 =
  idris_int_str idr_prim__toStrBigInt0

idr_Main.processInput idr_Main.processInput0 idr_Main.processInput1 =
  idr_Main.processInput2_val <- idr_Main.parse idr_Main.processInput1
  idr_Main.processInput2 <- store idr_Main.processInput2_val
  idr_Main.processInput2_val_498 <- fetch idr_Main.processInput2
  case idr_Main.processInput2_val_498 of
    (Cidr_Prelude.Maybe.Just idr_Main.processInput3) ->
      idr_Main.processInput3_val <- fetch idr_Main.processInput3
      case idr_Main.processInput3_val of
        (Cidr_Main.Add idr_Main.processInput4) ->
          idr_Main.processInput5_val_500 <- pure (CGrString #"ID ")
          idr_Main.processInput5 <- store idr_Main.processInput5_val_500
          idr_Main.processInput6_val_502 <- pure (CErased)
          idr_Main.processInput6 <- store idr_Main.processInput6_val_502
          idr_Main.processInput7_val <- pure (C"idr_{U_prim__toStrBigInt_1}")
          idr_Main.processInput7 <- store idr_Main.processInput7_val
          idr_Main.processInput8_val <- pure (Cidr_Prelude.Show.Open)
          idr_Main.processInput8 <- store idr_Main.processInput8_val
          idr_Main.processInput0_val <- fetch idr_Main.processInput0
          (Cidr_Main.MkData idr_Main.processInput9 idr_Main.processInput10) <- pure idr_Main.processInput0_val
          idr_Main.processInput9_val <- fetch idr_Main.processInput9
          idr_Main.processInput9_503 <- store idr_Main.processInput9_val
          idr_Main.processInput6_val_501 <- do
            (Cidr_Prelude.Show.Open) <- fetch idr_Main.processInput8
            idr_Prelude.Show.primNumShow idr_Main.processInput7 idr_Main.processInput9_503 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Show.Open)
          idr_Main.processInput6_504 <- store idr_Main.processInput6_val_501
          idr_Main.processInput7_val_505 <- pure (CGrString #"\n")
          idr_Main.processInput7_506 <- store idr_Main.processInput7_val_505
          idr_Main.processInput6_val <- idris_str_concat idr_Main.processInput6_504 idr_Main.processInput7_506
          idr_Main.processInput6_507 <- store idr_Main.processInput6_val
          idr_Main.processInput5_val_499 <- idris_str_concat idr_Main.processInput5 idr_Main.processInput6_507
          idr_Main.processInput5_508 <- store idr_Main.processInput5_val_499
          idr_Main.processInput0_val_510 <- fetch idr_Main.processInput0
          (Cidr_Main.MkData idr_Main.processInput6_511 idr_Main.processInput7_512) <- pure idr_Main.processInput0_val_510
          idr_Main.processInput8_val_514 <- pure (CGrInt 1)
          idr_Main.processInput8_515 <- store idr_Main.processInput8_val_514
          idr_Main.processInput8_val_513 <- do
            unboxed.CGrInt.43 <- do
              (CGrInt idr_Main.processInput6_511.32.43.arity.1) <- fetch idr_Main.processInput6_511
              (CGrInt idr_Main.processInput8_515.32.43.arity.1) <- fetch idr_Main.processInput8_515
              idris_int_add.unboxed idr_Main.processInput6_511.32.43.arity.1 idr_Main.processInput8_515.32.43.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.processInput8_515.32.43.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Main.processInput6_511.32.43.arity.1)
            pure (CGrInt unboxed.CGrInt.43) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.43)
          idr_Main.processInput8_516 <- store idr_Main.processInput8_val_513
          idr_Main.processInput9_val_518 <- pure (CErased)
          idr_Main.processInput9_519 <- store idr_Main.processInput9_val_518
          idr_Main.processInput10_val <- pure (CErased)
          idr_Main.processInput10_520 <- store idr_Main.processInput10_val
          idr_Main.processInput11_val <- pure (CErased)
          idr_Main.processInput11 <- store idr_Main.processInput11_val
          idr_Main.processInput9_val_517 <- idr_Main.addToStore:addToData:0 idr_Main.processInput4 idr_Main.processInput7_512
          idr_Main.processInput9_521 <- store idr_Main.processInput9_val_517
          idr_Main.processInput6_val_509 <- pure (Cidr_Main.MkData idr_Main.processInput8_516 idr_Main.processInput9_521)
          idr_Main.processInput6_522 <- store idr_Main.processInput6_val_509
          idr_Main.processInput5_val <- pure (Cidr_Builtins.MkPair idr_Main.processInput5_508 idr_Main.processInput6_522)
          idr_Main.processInput5_523 <- store idr_Main.processInput5_val
          pure (Cidr_Prelude.Maybe.Just idr_Main.processInput5_523) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.processInput5_523)
        (Cidr_Main.Get idr_Main.processInput4_524) ->
          idr_Main.getEntry idr_Main.processInput4_524 idr_Main.processInput0
        (Cidr_Main.Quit) ->
          pure (Cidr_Prelude.Maybe.Nothing) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Nothing)
        (Cidr_Main.Search idr_Main.processInput4_525) ->
          idr_Main.search idr_Main.processInput0 idr_Main.processInput4_525
        (Cidr_Main.Size) ->
          idr_Main.processInput4_val_527 <- pure (CGrString #"Size of store: ")
          idr_Main.processInput4_528 <- store idr_Main.processInput4_val_527
          idr_Main.processInput0_val_531 <- fetch idr_Main.processInput0
          (Cidr_Main.MkData idr_Main.processInput5_532 idr_Main.processInput6_533) <- pure idr_Main.processInput0_val_531
          idr_Main.processInput5_val_530 <- fetch idr_Main.processInput5_532
          idr_Main.processInput5_534 <- store idr_Main.processInput5_val_530
          idr_Main.processInput5_val_529 <- idris_int_str idr_Main.processInput5_534
          idr_Main.processInput5_535 <- store idr_Main.processInput5_val_529
          idr_Main.processInput4_val_526 <- idris_str_concat idr_Main.processInput4_528 idr_Main.processInput5_535
          idr_Main.processInput4_536 <- store idr_Main.processInput4_val_526
          idr_Main.processInput4_val <- pure (Cidr_Builtins.MkPair idr_Main.processInput4_536 idr_Main.processInput0)
          idr_Main.processInput4_537 <- store idr_Main.processInput4_val
          pure (Cidr_Prelude.Maybe.Just idr_Main.processInput4_537) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.processInput4_537)
    (Cidr_Prelude.Maybe.Nothing) ->
      idr_Main.processInput3_val_539 <- pure (CGrString #"Invalid command\n")
      idr_Main.processInput3_540 <- store idr_Main.processInput3_val_539
      idr_Main.processInput3_val_538 <- pure (Cidr_Builtins.MkPair idr_Main.processInput3_540 idr_Main.processInput0)
      idr_Main.processInput3_541 <- store idr_Main.processInput3_val_538
      pure (Cidr_Prelude.Maybe.Just idr_Main.processInput3_541) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.processInput3_541)

idr_Data.Vect.range idr_Data.Vect.range0 =
  idr_Data.Vect.range0_val <- fetch idr_Data.Vect.range0
  case idr_Data.Vect.range0_val of
    (CGrInt idr_Data.Vect.range_cpat_LInt64_0) ->
      case idr_Data.Vect.range_cpat_LInt64_0 of
        0 ->
          pure (Cidr_Data.Vect.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.Nil)
        #default ->
          idr_Data.Vect.range1_val_542 <- pure (CGrInt 1)
          idr_Data.Vect.range1 <- store idr_Data.Vect.range1_val_542
          idr_Data.Vect.range1_val <- do
            unboxed.CGrInt.44 <- do
              (CGrInt idr_Data.Vect.range0.32.44.arity.1) <- fetch idr_Data.Vect.range0
              (CGrInt idr_Data.Vect.range1.32.44.arity.1) <- fetch idr_Data.Vect.range1
              idris_int_sub.unboxed idr_Data.Vect.range0.32.44.arity.1 idr_Data.Vect.range1.32.44.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Vect.range1.32.44.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr_Data.Vect.range0.32.44.arity.1)
            pure (CGrInt unboxed.CGrInt.44) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.44)
          idr_Data.Vect.range1_543 <- store idr_Data.Vect.range1_val
          idr_Data.Vect.range2_val <- pure (Cidr_Data.Fin.FZ)
          idr_Data.Vect.range2 <- store idr_Data.Vect.range2_val
          idr_Data.Vect.range3_val_544 <- pure (CErased)
          idr_Data.Vect.range3 <- store idr_Data.Vect.range3_val_544
          idr_Data.Vect.range4_val <- pure (CErased)
          idr_Data.Vect.range4 <- store idr_Data.Vect.range4_val
          idr_Data.Vect.range5_val <- pure (CErased)
          idr_Data.Vect.range5 <- store idr_Data.Vect.range5_val
          idr_Data.Vect.range6_val <- pure (C"idr_{U_Data.Vect.{range_5}_1}")
          idr_Data.Vect.range6 <- store idr_Data.Vect.range6_val
          idr_Data.Vect.range7_val <- idr_Data.Vect.range idr_Data.Vect.range1_543
          idr_Data.Vect.range7 <- store idr_Data.Vect.range7_val
          idr_Data.Vect.range3_val <- "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:0" idr_Data.Vect.range6 idr_Data.Vect.range7
          idr_Data.Vect.range3_545 <- store idr_Data.Vect.range3_val
          pure (Cidr_Data.Vect.:: idr_Data.Vect.range2 idr_Data.Vect.range3_545) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.:: idr_Data.Vect.range2 idr_Data.Vect.range3_545)

idr_Prelude.Interactive.replWith idr_Prelude.Interactive.replWith1 idr_Prelude.Interactive.replWith2 idr_Prelude.Interactive.replWith3 idr_Prelude.Interactive.replWith4 =
  idr_Prelude.Interactive.replWith5_val_564 <- do
    unboxed.CGrInt.45 <- idr_prim__stdin.unboxed
    pure (CGrInt unboxed.CGrInt.45) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.45)
  idr_Prelude.Interactive.replWith5 <- store idr_Prelude.Interactive.replWith5_val_564
  idr_Prelude.Interactive.replWith5_val <- idr_Prelude.File.fEOF idr_Prelude.Interactive.replWith5
  idr_Prelude.Interactive.replWith5_565 <- store idr_Prelude.Interactive.replWith5_val
  idr_Prelude.Interactive.replWith5_val_566 <- fetch idr_Prelude.Interactive.replWith5_565
  case idr_Prelude.Interactive.replWith5_val_566 of
    (Cidr_Prelude.Bool.False) ->
      idr_Prelude.Interactive.replWith6_val_567 <- idris_write_str idr_Prelude.Interactive.replWith2
      idr_Prelude.Interactive.replWith6 <- store idr_Prelude.Interactive.replWith6_val_567
      idr_Prelude.Interactive.replWith6_val <- pure (Cidr_MkUnit)
      idr_Prelude.Interactive.replWith6_568 <- store idr_Prelude.Interactive.replWith6_val
      idr_Prelude.Interactive.replWith7_val_569 <- pure (CErased)
      idr_Prelude.Interactive.replWith7 <- store idr_Prelude.Interactive.replWith7_val_569
      idr_Prelude.Interactive.replWith7_val <- do
        unboxed.CGrString.46 <- idr_Prelude.Interactive.getLine'.unboxed
        pure (CGrString unboxed.CGrString.46) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.46)
      idr_Prelude.Interactive.replWith7_570 <- store idr_Prelude.Interactive.replWith7_val
      idr_Prelude.Interactive.replWith8_val_571 <- do
        "idr_{APPLY_0}0.7" <- pure idr_Prelude.Interactive.replWith3
        "idr_{APPLY_0}1.7" <- pure idr_Prelude.Interactive.replWith1
        "idr_{APPLY_0}0_val.7" <- fetch "idr_{APPLY_0}0.7"
        case "idr_{APPLY_0}0_val.7" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.7" "idr_{APPLY_0}3.7" "idr_{APPLY_0}4.7") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.7" "idr_{APPLY_0}3.7" "idr_{APPLY_0}4.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.7") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.7") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.7") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.7" "idr_{APPLY_0}3_637.7") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.7" "idr_{APPLY_0}3_637.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.7"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.7" "idr_{APPLY_0}3_639.7" "idr_{APPLY_0}4_640.7" "idr_{APPLY_0}5.7") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.7" "idr_{APPLY_0}4_640.7" "idr_{APPLY_0}5.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.7") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.7"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.7" "idr_{APPLY_0}3_643.7" "idr_{APPLY_0}4_644.7") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.7" "idr_{APPLY_0}3_643.7" "idr_{APPLY_0}4_644.7"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.7"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.7") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.7" "idr_{APPLY_0}3_648.7") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.7" "idr_{APPLY_0}3_648.7" "idr_{APPLY_0}1.7"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.7")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.7")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.7")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.7") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.7" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.7" "idr_{APPLY_0}1.7")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.7")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.7") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.7" "idr_{APPLY_0}1.7") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.7" "idr_{APPLY_0}1.7")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      idr_Prelude.Interactive.replWith8 <- store idr_Prelude.Interactive.replWith8_val_571
      idr_Prelude.Interactive.replWith8_val <- do
        "idr_{APPLY_0}0.8" <- pure idr_Prelude.Interactive.replWith8
        "idr_{APPLY_0}1.8" <- pure idr_Prelude.Interactive.replWith7_570
        "idr_{APPLY_0}0_val.8" <- fetch "idr_{APPLY_0}0.8"
        case "idr_{APPLY_0}0_val.8" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.8" "idr_{APPLY_0}3.8" "idr_{APPLY_0}4.8") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.8" "idr_{APPLY_0}3.8" "idr_{APPLY_0}4.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.8") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.8") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.8") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.8" "idr_{APPLY_0}3_637.8") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.8" "idr_{APPLY_0}3_637.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.8"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.8" "idr_{APPLY_0}3_639.8" "idr_{APPLY_0}4_640.8" "idr_{APPLY_0}5.8") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.8" "idr_{APPLY_0}4_640.8" "idr_{APPLY_0}5.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.8") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.8"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.8" "idr_{APPLY_0}3_643.8" "idr_{APPLY_0}4_644.8") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.8" "idr_{APPLY_0}3_643.8" "idr_{APPLY_0}4_644.8"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.8"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.8") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.8" "idr_{APPLY_0}3_648.8") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.8" "idr_{APPLY_0}3_648.8" "idr_{APPLY_0}1.8"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.8")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.8")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.8")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.8") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.8" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.8" "idr_{APPLY_0}1.8")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.8")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.8") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.8" "idr_{APPLY_0}1.8") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.8" "idr_{APPLY_0}1.8")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      idr_Prelude.Interactive.replWith8_572 <- store idr_Prelude.Interactive.replWith8_val
      idr_Prelude.Interactive.replWith8_val_573 <- fetch idr_Prelude.Interactive.replWith8_572
      case idr_Prelude.Interactive.replWith8_val_573 of
        (Cidr_Prelude.Maybe.Just idr_Prelude.Interactive.replWith9) ->
          idr_Prelude.Interactive.replWith9_val <- fetch idr_Prelude.Interactive.replWith9
          (Cidr_Builtins.MkPair idr_Prelude.Interactive.replWith10 idr_Prelude.Interactive.replWith11) <- pure idr_Prelude.Interactive.replWith9_val
          idr_Prelude.Interactive.replWith12_val <- pure (CErased)
          idr_Prelude.Interactive.replWith12 <- store idr_Prelude.Interactive.replWith12_val
          idr_Prelude.Interactive.replWith13_val <- pure (CErased)
          idr_Prelude.Interactive.replWith13 <- store idr_Prelude.Interactive.replWith13_val
          idr_Prelude.Interactive.replWith14_val <- pure (CErased)
          idr_Prelude.Interactive.replWith14 <- store idr_Prelude.Interactive.replWith14_val
          idr_Prelude.Interactive.replWith15_val <- pure (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" idr_Prelude.Interactive.replWith10)
          idr_Prelude.Interactive.replWith15 <- store idr_Prelude.Interactive.replWith15_val
          idr_Prelude.Interactive.replWith16_val <- pure (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" idr_Prelude.Interactive.replWith11 idr_Prelude.Interactive.replWith2 idr_Prelude.Interactive.replWith3)
          idr_Prelude.Interactive.replWith16 <- store idr_Prelude.Interactive.replWith16_val
          idr_io_bind idr_Prelude.Interactive.replWith15 idr_Prelude.Interactive.replWith16 idr_Prelude.Interactive.replWith4
        (Cidr_Prelude.Maybe.Nothing) ->
          pure (Cidr_MkUnit) -- LINT: Last return expressions can only return non-node values: pure (Cidr_MkUnit)
    (Cidr_Prelude.Bool.True) ->
      pure (Cidr_MkUnit) -- LINT: Last return expressions can only return non-node values: pure (Cidr_MkUnit)

idr_Main.search idr_Main.search0 idr_Main.search1 =
  idr_Main.search0_val <- fetch idr_Main.search0
  (Cidr_Main.MkData idr_Main.search2 idr_Main.search3) <- pure idr_Main.search0_val
  idr_Main.search2_val <- fetch idr_Main.search3
  idr_Main.search2_574 <- store idr_Main.search2_val
  idr_Main.search3_val_576 <- pure (CErased)
  idr_Main.search3_577 <- store idr_Main.search3_val_576
  idr_Main.search4_val <- pure (CErased)
  idr_Main.search4 <- store idr_Main.search4_val
  idr_Main.search5_val <- pure (CErased)
  idr_Main.search5 <- store idr_Main.search5_val
  idr_Main.search6_val <- pure (C"idr_{U_Main.{search_8}_2}" idr_Main.search1)
  idr_Main.search6 <- store idr_Main.search6_val
  idr_Main.search7_val <- pure (CGrString #"")
  idr_Main.search7 <- store idr_Main.search7_val
  idr_Main.search8_val <- pure (C"idr_{U_Main.{search_9}_1}")
  idr_Main.search8 <- store idr_Main.search8_val
  idr_Main.search9_val_578 <- pure (CErased)
  idr_Main.search9 <- store idr_Main.search9_val_578
  idr_Main.search10_val <- pure (CErased)
  idr_Main.search10 <- store idr_Main.search10_val
  idr_Main.search11_val <- pure (CErased)
  idr_Main.search11 <- store idr_Main.search11_val
  idr_Main.search12_val <- pure (CErased)
  idr_Main.search12 <- store idr_Main.search12_val
  idr_Main.search13_val <- pure (C"idr_{U_Main.{search_10}_2}")
  idr_Main.search13 <- store idr_Main.search13_val
  idr_Main.search0_val_580 <- fetch idr_Main.search0
  (Cidr_Main.MkData idr_Main.search14 idr_Main.search15) <- pure idr_Main.search0_val_580
  idr_Main.search14_val_579 <- fetch idr_Main.search14
  idr_Main.search14_581 <- store idr_Main.search14_val_579
  idr_Main.search14_val <- idr_Data.Vect.range idr_Main.search14_581
  idr_Main.search14_582 <- store idr_Main.search14_val
  idr_Main.search9_val <- idr_Data.Vect.zipWith idr_Main.search13 idr_Main.search14_582 idr_Main.search2_574
  idr_Main.search9_583 <- store idr_Main.search9_val
  idr_Main.search3_val_575 <- idr_Data.Vect.foldrImpl idr_Main.search6 idr_Main.search7 idr_Main.search8 idr_Main.search9_583
  idr_Main.search3_584 <- store idr_Main.search3_val_575
  idr_Main.search3_val <- pure (Cidr_Builtins.MkPair idr_Main.search3_584 idr_Main.search0)
  idr_Main.search3_585 <- store idr_Main.search3_val
  pure (Cidr_Prelude.Maybe.Just idr_Main.search3_585) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Maybe.Just idr_Main.search3_585)

idr_Prelude.List.tails idr_Prelude.List.tails1 =
  idr_Prelude.List.tails1_val <- fetch idr_Prelude.List.tails1
  idr_Prelude.List.tails2_val <- case idr_Prelude.List.tails1_val of
    (Cidr_Prelude.List.:: idr_Prelude.List.tails2 idr_Prelude.List.tails3) ->
      idr_Prelude.List.tails4_val <- pure (CErased)
      idr_Prelude.List.tails4 <- store idr_Prelude.List.tails4_val
      idr_Prelude.List.tails idr_Prelude.List.tails3
    (Cidr_Prelude.List.Nil) ->
      fetch idr_Prelude.List.tails1
  idr_Prelude.List.tails2_616 <- store idr_Prelude.List.tails2_val
  pure (Cidr_Prelude.List.:: idr_Prelude.List.tails1 idr_Prelude.List.tails2_616) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr_Prelude.List.tails1 idr_Prelude.List.tails2_616)

idr_Data.Vect.zipWith idr_Data.Vect.zipWith4 idr_Data.Vect.zipWith5 idr_Data.Vect.zipWith6 =
  idr_Data.Vect.zipWith6_val <- fetch idr_Data.Vect.zipWith6
  case idr_Data.Vect.zipWith6_val of
    (Cidr_Data.Vect.:: idr_Data.Vect.zipWith7 idr_Data.Vect.zipWith8) ->
      idr_Data.Vect.zipWith5_val <- fetch idr_Data.Vect.zipWith5
      (Cidr_Data.Vect.:: idr_Data.Vect.zipWith9 idr_Data.Vect.zipWith10) <- pure idr_Data.Vect.zipWith5_val
      idr_Data.Vect.zipWith11_val_629 <- do
        "idr_{APPLY_0}0.9" <- pure idr_Data.Vect.zipWith4
        "idr_{APPLY_0}1.9" <- pure idr_Data.Vect.zipWith9
        "idr_{APPLY_0}0_val.9" <- fetch "idr_{APPLY_0}0.9"
        case "idr_{APPLY_0}0_val.9" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.9" "idr_{APPLY_0}3.9" "idr_{APPLY_0}4.9") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.9" "idr_{APPLY_0}3.9" "idr_{APPLY_0}4.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.9") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.9") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.9") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.9" "idr_{APPLY_0}3_637.9") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.9" "idr_{APPLY_0}3_637.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.9"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.9" "idr_{APPLY_0}3_639.9" "idr_{APPLY_0}4_640.9" "idr_{APPLY_0}5.9") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.9" "idr_{APPLY_0}4_640.9" "idr_{APPLY_0}5.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.9") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.9"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.9" "idr_{APPLY_0}3_643.9" "idr_{APPLY_0}4_644.9") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.9" "idr_{APPLY_0}3_643.9" "idr_{APPLY_0}4_644.9"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.9"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.9") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.9" "idr_{APPLY_0}3_648.9") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.9" "idr_{APPLY_0}3_648.9" "idr_{APPLY_0}1.9"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.9")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.9")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.9")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.9") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.9" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.9" "idr_{APPLY_0}1.9")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.9")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.9") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.9" "idr_{APPLY_0}1.9") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.9" "idr_{APPLY_0}1.9")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      idr_Data.Vect.zipWith11 <- store idr_Data.Vect.zipWith11_val_629
      idr_Data.Vect.zipWith11_val <- do
        "idr_{APPLY_0}0.10" <- pure idr_Data.Vect.zipWith11
        "idr_{APPLY_0}1.10" <- pure idr_Data.Vect.zipWith7
        "idr_{APPLY_0}0_val.10" <- fetch "idr_{APPLY_0}0.10"
        case "idr_{APPLY_0}0_val.10" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.10" "idr_{APPLY_0}3.10" "idr_{APPLY_0}4.10") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.10" "idr_{APPLY_0}3.10" "idr_{APPLY_0}4.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.10") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.10") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.10") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.10" "idr_{APPLY_0}3_637.10") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.10" "idr_{APPLY_0}3_637.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.10"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.10" "idr_{APPLY_0}3_639.10" "idr_{APPLY_0}4_640.10" "idr_{APPLY_0}5.10") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.10" "idr_{APPLY_0}4_640.10" "idr_{APPLY_0}5.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.10") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.10"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.10" "idr_{APPLY_0}3_643.10" "idr_{APPLY_0}4_644.10") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.10" "idr_{APPLY_0}3_643.10" "idr_{APPLY_0}4_644.10"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.10"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.10") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.10" "idr_{APPLY_0}3_648.10") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.10" "idr_{APPLY_0}3_648.10" "idr_{APPLY_0}1.10"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.10")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.10")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.10")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.10") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.10" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.10" "idr_{APPLY_0}1.10")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.10")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.10") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.10" "idr_{APPLY_0}1.10") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.10" "idr_{APPLY_0}1.10")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      idr_Data.Vect.zipWith11_630 <- store idr_Data.Vect.zipWith11_val
      idr_Data.Vect.zipWith12_val_631 <- pure (CErased)
      idr_Data.Vect.zipWith12 <- store idr_Data.Vect.zipWith12_val_631
      idr_Data.Vect.zipWith13_val <- pure (CErased)
      idr_Data.Vect.zipWith13 <- store idr_Data.Vect.zipWith13_val
      idr_Data.Vect.zipWith14_val <- pure (CErased)
      idr_Data.Vect.zipWith14 <- store idr_Data.Vect.zipWith14_val
      idr_Data.Vect.zipWith15_val <- pure (CErased)
      idr_Data.Vect.zipWith15 <- store idr_Data.Vect.zipWith15_val
      idr_Data.Vect.zipWith12_val <- idr_Data.Vect.zipWith idr_Data.Vect.zipWith4 idr_Data.Vect.zipWith10 idr_Data.Vect.zipWith8
      idr_Data.Vect.zipWith12_632 <- store idr_Data.Vect.zipWith12_val
      pure (Cidr_Data.Vect.:: idr_Data.Vect.zipWith11_630 idr_Data.Vect.zipWith12_632) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.:: idr_Data.Vect.zipWith11_630 idr_Data.Vect.zipWith12_632)
    (Cidr_Data.Vect.Nil) ->
      fetch idr_Data.Vect.zipWith6

"idr_{PE_isInfixOf_22f242c8_0}" "idr_{PE_isInfixOf_22f242c8_0}0" "idr_{PE_isInfixOf_22f242c8_0}1" =
  "idr_{PE_isInfixOf_22f242c8_0}2_val" <- do
    unboxed.CGrInt.46 <- idris_int_eq.unboxed "idr_{PE_isInfixOf_22f242c8_0}0" "idr_{PE_isInfixOf_22f242c8_0}1"
    pure (CGrInt unboxed.CGrInt.46) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.46)
  "idr_{PE_isInfixOf_22f242c8_0}2" <- store "idr_{PE_isInfixOf_22f242c8_0}2_val"
  "idr_{PE_isInfixOf_22f242c8_0}2_val_653" <- fetch "idr_{PE_isInfixOf_22f242c8_0}2"
  case "idr_{PE_isInfixOf_22f242c8_0}2_val_653" of
    (CGrInt "idr_{PE_isInfixOf_22f242c8_0}_cpat_LInt64_0") ->
      case "idr_{PE_isInfixOf_22f242c8_0}_cpat_LInt64_0" of
        0 ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
        #default ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)

"idr_{runMain_0}" =
  "idr_{runMain_0}0_val_654" <- pure (CErased)
  "idr_{runMain_0}0" <- store "idr_{runMain_0}0_val_654"
  "idr_{runMain_0}1_val_655" <- pure (CGrInt 0)
  "idr_{runMain_0}1" <- store "idr_{runMain_0}1_val_655"
  "idr_{runMain_0}2_val" <- pure (Cidr_Data.Vect.Nil)
  "idr_{runMain_0}2" <- store "idr_{runMain_0}2_val"
  "idr_{runMain_0}1_val" <- pure (Cidr_Main.MkData "idr_{runMain_0}1" "idr_{runMain_0}2")
  "idr_{runMain_0}1_656" <- store "idr_{runMain_0}1_val"
  "idr_{runMain_0}2_val_657" <- pure (CGrString #"Command: ")
  "idr_{runMain_0}2_658" <- store "idr_{runMain_0}2_val_657"
  "idr_{runMain_0}3_val" <- pure (C"idr_{U_Main.processInput_2}")
  "idr_{runMain_0}3" <- store "idr_{runMain_0}3_val"
  "idr_{runMain_0}4_val" <- pure (CErased)
  "idr_{runMain_0}4" <- store "idr_{runMain_0}4_val"
  "idr_{runMain_0}0_val" <- idr_Prelude.Interactive.replWith "idr_{runMain_0}1_656" "idr_{runMain_0}2_658" "idr_{runMain_0}3" "idr_{runMain_0}4"
  "idr_{runMain_0}0_659" <- store "idr_{runMain_0}0_val"
  do
    "idr_{EVAL_0}0.0" <- pure "idr_{runMain_0}0_659"
    "idr_{EVAL_0}0_val.0" <- fetch "idr_{EVAL_0}0.0"
    fetch "idr_{EVAL_0}0.0"

"idr_{PE_isInfixOf_22f242c8_1}" "idr_{PE_isInfixOf_22f242c8_1}0" "idr_{PE_isInfixOf_22f242c8_1}1" "idr_{PE_isInfixOf_22f242c8_1}2" =
  "idr_{PE_isInfixOf_22f242c8_1}1_val" <- fetch "idr_{PE_isInfixOf_22f242c8_1}1"
  case "idr_{PE_isInfixOf_22f242c8_1}1_val" of
    (Cidr_Prelude.Bool.False) ->
      "idr_{PE_isInfixOf_22f242c8_1}3_val" <- pure (CErased)
      "idr_{PE_isInfixOf_22f242c8_1}3" <- store "idr_{PE_isInfixOf_22f242c8_1}3_val"
      "idr_{PE_isInfixOf_22f242c8_1}4_val" <- pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}")
      "idr_{PE_isInfixOf_22f242c8_1}4" <- store "idr_{PE_isInfixOf_22f242c8_1}4_val"
      idr_Prelude.List.isPrefixOfBy "idr_{PE_isInfixOf_22f242c8_1}4" "idr_{PE_isInfixOf_22f242c8_1}0" "idr_{PE_isInfixOf_22f242c8_1}2"
    (Cidr_Prelude.Bool.True) ->
      fetch "idr_{PE_isInfixOf_22f242c8_1}1"

"idr_Data.Vect.{foldrImpl_2}" "idr_Data.Vect.{foldrImpl_2}0" "idr_Data.Vect.{foldrImpl_2}1" "idr_Data.Vect.{foldrImpl_2}2" "idr_Data.Vect.{foldrImpl_2}3" =
  "idr_Data.Vect.{foldrImpl_2}4_val_660" <- do
    "idr_{APPLY_0}0.11" <- pure "idr_Data.Vect.{foldrImpl_2}1"
    "idr_{APPLY_0}1.11" <- pure "idr_Data.Vect.{foldrImpl_2}2"
    "idr_{APPLY_0}0_val.11" <- fetch "idr_{APPLY_0}0.11"
    case "idr_{APPLY_0}0_val.11" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.11" "idr_{APPLY_0}3.11" "idr_{APPLY_0}4.11") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.11" "idr_{APPLY_0}3.11" "idr_{APPLY_0}4.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.11") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.11") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.11") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.11" "idr_{APPLY_0}3_637.11") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.11" "idr_{APPLY_0}3_637.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.11"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.11" "idr_{APPLY_0}3_639.11" "idr_{APPLY_0}4_640.11" "idr_{APPLY_0}5.11") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.11" "idr_{APPLY_0}4_640.11" "idr_{APPLY_0}5.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.11") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.11"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.11" "idr_{APPLY_0}3_643.11" "idr_{APPLY_0}4_644.11") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.11" "idr_{APPLY_0}3_643.11" "idr_{APPLY_0}4_644.11"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.11"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.11") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.11" "idr_{APPLY_0}3_648.11") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.11" "idr_{APPLY_0}3_648.11" "idr_{APPLY_0}1.11"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.11")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.11")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.11")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.11") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.11" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.11" "idr_{APPLY_0}1.11")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.11")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.11") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.11" "idr_{APPLY_0}1.11") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.11" "idr_{APPLY_0}1.11")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
  "idr_Data.Vect.{foldrImpl_2}4" <- store "idr_Data.Vect.{foldrImpl_2}4_val_660"
  "idr_Data.Vect.{foldrImpl_2}4_val" <- do
    "idr_{APPLY_0}0.12" <- pure "idr_Data.Vect.{foldrImpl_2}4"
    "idr_{APPLY_0}1.12" <- pure "idr_Data.Vect.{foldrImpl_2}3"
    "idr_{APPLY_0}0_val.12" <- fetch "idr_{APPLY_0}0.12"
    case "idr_{APPLY_0}0_val.12" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.12" "idr_{APPLY_0}3.12" "idr_{APPLY_0}4.12") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.12" "idr_{APPLY_0}3.12" "idr_{APPLY_0}4.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.12") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.12") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.12") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.12" "idr_{APPLY_0}3_637.12") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.12" "idr_{APPLY_0}3_637.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.12"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.12" "idr_{APPLY_0}3_639.12" "idr_{APPLY_0}4_640.12" "idr_{APPLY_0}5.12") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.12" "idr_{APPLY_0}4_640.12" "idr_{APPLY_0}5.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.12") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.12"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.12" "idr_{APPLY_0}3_643.12" "idr_{APPLY_0}4_644.12") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.12" "idr_{APPLY_0}3_643.12" "idr_{APPLY_0}4_644.12"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.12"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.12") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.12" "idr_{APPLY_0}3_648.12") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.12" "idr_{APPLY_0}3_648.12" "idr_{APPLY_0}1.12"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.12")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.12")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.12")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.12") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.12" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.12" "idr_{APPLY_0}1.12")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.12")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.12") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.12" "idr_{APPLY_0}1.12") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.12" "idr_{APPLY_0}1.12")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
  "idr_Data.Vect.{foldrImpl_2}4_661" <- store "idr_Data.Vect.{foldrImpl_2}4_val"
  do
    "idr_{APPLY_0}0.13" <- pure "idr_Data.Vect.{foldrImpl_2}0"
    "idr_{APPLY_0}1.13" <- pure "idr_Data.Vect.{foldrImpl_2}4_661"
    "idr_{APPLY_0}0_val.13" <- fetch "idr_{APPLY_0}0.13"
    case "idr_{APPLY_0}0_val.13" of
      (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.13" "idr_{APPLY_0}3.13" "idr_{APPLY_0}4.13") ->
        "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.13" "idr_{APPLY_0}3.13" "idr_{APPLY_0}4.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Data.Vect.{range_5}_1}") ->
        "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.13") ->
        idr_Main.processInput "idr_{APPLY_0}2_633.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.13") ->
        "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.{parse_3}_1}") ->
        "idr_Main.{parse_3}" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.13") ->
        "idr_Main.{search_10}" "idr_{APPLY_0}2_635.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.13" "idr_{APPLY_0}3_637.13") ->
        "idr_Main.{search_8}" "idr_{APPLY_0}2_636.13" "idr_{APPLY_0}3_637.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.{search_9}_1}") ->
        "idr_Main.{search_9}" "idr_{APPLY_0}1.13"
      (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.13" "idr_{APPLY_0}3_639.13" "idr_{APPLY_0}4_640.13" "idr_{APPLY_0}5.13") ->
        idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.13" "idr_{APPLY_0}4_640.13" "idr_{APPLY_0}5.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.13") ->
        "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.13"
      (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.13" "idr_{APPLY_0}3_643.13" "idr_{APPLY_0}4_644.13") ->
        "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.13" "idr_{APPLY_0}3_643.13" "idr_{APPLY_0}4_644.13"
      (C"idr_{U_prim__toStrBigInt_1}") ->
        idr_prim__toStrBigInt "idr_{APPLY_0}1.13"
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.13") ->
        "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.13" "idr_{APPLY_0}3_648.13") ->
        "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.13" "idr_{APPLY_0}3_648.13" "idr_{APPLY_0}1.13"
      (C"idr_{U_Main.processInput_2}") ->
        pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.13")
      (C"idr_{U_Main.{parseCommand_4}_2}") ->
        pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.13")
      (C"idr_{U_Main.{search_10}_2}") ->
        pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.13")
      (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.13") ->
        pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.13" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.13" "idr_{APPLY_0}1.13")
      (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.13")
      (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.13") ->
        pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.13" "idr_{APPLY_0}1.13") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.13" "idr_{APPLY_0}1.13")
      #default ->
        pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)

"idr_Main.{parse_3}" "idr_Main.{parse_3}0" =
  "idr_Main.{parse_3}1_val_662" <- pure (CGrInt 32)
  "idr_Main.{parse_3}1" <- store "idr_Main.{parse_3}1_val_662"
  "idr_Main.{parse_3}1_val" <- do
    unboxed.CGrInt.47 <- idris_int_eq.unboxed "idr_Main.{parse_3}0" "idr_Main.{parse_3}1"
    pure (CGrInt unboxed.CGrInt.47) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.47)
  "idr_Main.{parse_3}1_663" <- store "idr_Main.{parse_3}1_val"
  "idr_Main.{parse_3}1_val_664" <- fetch "idr_Main.{parse_3}1_663"
  case "idr_Main.{parse_3}1_val_664" of
    (CGrInt "idr_Main.{parse_3}_cpat_LInt64_0") ->
      case "idr_Main.{parse_3}_cpat_LInt64_0" of
        0 ->
          pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
        #default ->
          pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)

"idr_Main.{parseCommand_4}" "idr_Main.{parseCommand_4}0" "idr_Main.{parseCommand_4}1" =
  "idr_Main.{parseCommand_4}0_val" <- fetch "idr_Main.{parseCommand_4}0"
  case "idr_Main.{parseCommand_4}0_val" of
    (Cidr_Prelude.Bool.False) ->
      fetch "idr_Main.{parseCommand_4}0"
    (Cidr_Prelude.Bool.True) ->
      idr_Prelude.Chars.isDigit "idr_Main.{parseCommand_4}1"

"idr_Data.Vect.{range_5}" "idr_Data.Vect.{range_5}0" =
  pure (Cidr_Data.Fin.FS "idr_Data.Vect.{range_5}0") -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Fin.FS "idr_Data.Vect.{range_5}0")

"idr_Prelude.Interactive.{replWith_6}" "idr_Prelude.Interactive.{replWith_6}0" =
  "idr_Prelude.Interactive.{replWith_6}2_val" <- idris_write_str "idr_Prelude.Interactive.{replWith_6}0"
  "idr_Prelude.Interactive.{replWith_6}2" <- store "idr_Prelude.Interactive.{replWith_6}2_val"
  pure (Cidr_MkUnit) -- LINT: Last return expressions can only return non-node values: pure (Cidr_MkUnit)

"idr_Prelude.Interactive.{replWith_7}" "idr_Prelude.Interactive.{replWith_7}0" "idr_Prelude.Interactive.{replWith_7}1" "idr_Prelude.Interactive.{replWith_7}2" =
  "idr_Prelude.Interactive.{replWith_7}4_val" <- pure (CErased)
  "idr_Prelude.Interactive.{replWith_7}4" <- store "idr_Prelude.Interactive.{replWith_7}4_val"
  pure (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_Prelude.Interactive.{replWith_7}4" "idr_Prelude.Interactive.{replWith_7}0" "idr_Prelude.Interactive.{replWith_7}1" "idr_Prelude.Interactive.{replWith_7}2") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_Prelude.Interactive.{replWith_7}4" "idr_Prelude.Interactive.{replWith_7}0" "idr_Prelude.Interactive.{replWith_7}1" "idr_Prelude.Interactive.{replWith_7}2")

"idr_Main.{search_8}" "idr_Main.{search_8}0" "idr_Main.{search_8}1" "idr_Main.{search_8}2" =
  "idr_Main.{search_8}1_val" <- fetch "idr_Main.{search_8}1"
  (Cidr_Builtins.MkPair "idr_Main.{search_8}3" "idr_Main.{search_8}4") <- pure "idr_Main.{search_8}1_val"
  "idr_Main.{search_8}5_val" <- idr_Prelude.Strings.isInfixOf "idr_Main.{search_8}0" "idr_Main.{search_8}4"
  "idr_Main.{search_8}5" <- store "idr_Main.{search_8}5_val"
  "idr_Main.{search_8}5_val_665" <- fetch "idr_Main.{search_8}5"
  case "idr_Main.{search_8}5_val_665" of
    (Cidr_Prelude.Bool.False) ->
      fetch "idr_Main.{search_8}2"
    (Cidr_Prelude.Bool.True) ->
      "idr_Main.{search_8}6_val_667" <- pure (CErased)
      "idr_Main.{search_8}6" <- store "idr_Main.{search_8}6_val_667"
      "idr_Main.{search_8}6_val_666" <- do
        unboxed.CGrInt.48 <- idr_Data.Fin.finToInteger.unboxed "idr_Main.{search_8}3"
        pure (CGrInt unboxed.CGrInt.48) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.48)
      "idr_Main.{search_8}6_668" <- store "idr_Main.{search_8}6_val_666"
      "idr_Main.{search_8}6_val" <- idris_int_str "idr_Main.{search_8}6_668"
      "idr_Main.{search_8}6_669" <- store "idr_Main.{search_8}6_val"
      "idr_Main.{search_8}7_val_670" <- pure (CGrString #": ")
      "idr_Main.{search_8}7" <- store "idr_Main.{search_8}7_val_670"
      "idr_Main.{search_8}8_val_672" <- pure (CGrString #"\n")
      "idr_Main.{search_8}8" <- store "idr_Main.{search_8}8_val_672"
      "idr_Main.{search_8}8_val_671" <- idris_str_concat "idr_Main.{search_8}8" "idr_Main.{search_8}2"
      "idr_Main.{search_8}8_673" <- store "idr_Main.{search_8}8_val_671"
      "idr_Main.{search_8}8_val" <- idris_str_concat "idr_Main.{search_8}4" "idr_Main.{search_8}8_673"
      "idr_Main.{search_8}8_674" <- store "idr_Main.{search_8}8_val"
      "idr_Main.{search_8}7_val" <- idris_str_concat "idr_Main.{search_8}7" "idr_Main.{search_8}8_674"
      "idr_Main.{search_8}7_675" <- store "idr_Main.{search_8}7_val"
      idris_str_concat "idr_Main.{search_8}6_669" "idr_Main.{search_8}7_675"

"idr_Main.{search_9}" "idr_Main.{search_9}0" =
  fetch "idr_Main.{search_9}0"

"idr_Main.{search_10}" "idr_Main.{search_10}0" "idr_Main.{search_10}1" =
  pure (Cidr_Builtins.MkPair "idr_Main.{search_10}0" "idr_Main.{search_10}1") -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair "idr_Main.{search_10}0" "idr_Main.{search_10}1")

"idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}" "idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}0" =
  "idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}2_val" <- idris_write_str "idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}0"
  "idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}2" <- store "idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_11}2_val"
  pure (Cidr_MkUnit) -- LINT: Last return expressions can only return non-node values: pure (Cidr_MkUnit)

"idr_Prelude.Interactive.{replWith_____Prelude__Interactive__idr_167_22_167_29_case_lam_13}" =
  pure (Cidr_MkUnit) -- LINT: Last return expressions can only return non-node values: pure (Cidr_MkUnit)

idr_Main.addToStore:addToData:0 idr_Main.addToStore:addToData:03 idr_Main.addToStore:addToData:04 =
  idr_Main.addToStore:addToData:04_val <- fetch idr_Main.addToStore:addToData:04
  case idr_Main.addToStore:addToData:04_val of
    (Cidr_Data.Vect.:: idr_Main.addToStore:addToData:05 idr_Main.addToStore:addToData:06) ->
      idr_Main.addToStore:addToData:07_val_676 <- pure (CErased)
      idr_Main.addToStore:addToData:07 <- store idr_Main.addToStore:addToData:07_val_676
      idr_Main.addToStore:addToData:08_val <- pure (CErased)
      idr_Main.addToStore:addToData:08 <- store idr_Main.addToStore:addToData:08_val
      idr_Main.addToStore:addToData:09_val <- pure (CErased)
      idr_Main.addToStore:addToData:09 <- store idr_Main.addToStore:addToData:09_val
      idr_Main.addToStore:addToData:07_val <- idr_Main.addToStore:addToData:0 idr_Main.addToStore:addToData:03 idr_Main.addToStore:addToData:06
      idr_Main.addToStore:addToData:07_677 <- store idr_Main.addToStore:addToData:07_val
      pure (Cidr_Data.Vect.:: idr_Main.addToStore:addToData:05 idr_Main.addToStore:addToData:07_677) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.:: idr_Main.addToStore:addToData:05 idr_Main.addToStore:addToData:07_677)
    (Cidr_Data.Vect.Nil) ->
      idr_Main.addToStore:addToData:05_val <- pure (Cidr_Data.Vect.Nil)
      idr_Main.addToStore:addToData:05_678 <- store idr_Main.addToStore:addToData:05_val
      pure (Cidr_Data.Vect.:: idr_Main.addToStore:addToData:03 idr_Main.addToStore:addToData:05_678) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.:: idr_Main.addToStore:addToData:03 idr_Main.addToStore:addToData:05_678)

"idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:00" =
  "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:01_val" <- pure (Cidr_Prelude.Bool.True)
  case "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:01_val" of
    (Cidr_Prelude.Bool.True) ->
      "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:00_val_679" <- fetch "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:00"
      case "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:00_val_679" of
        (Cidr_Prelude.Bool.False) ->
          pure (Cidr_Prelude.Basics.No) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Basics.No)
        (Cidr_Prelude.Bool.True) ->
          pure (Cidr_Prelude.Basics.Yes) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Basics.Yes)

"idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:0" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:02" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:03" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:04" =
  "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:04_val" <- fetch "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:04"
  case "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:04_val" of
    (Cidr_Prelude.List.:: "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:05" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:06") ->
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:07_val" <- pure (CErased)
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:07" <- store "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:07_val"
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:08_val" <- pure (CErased)
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:08" <- store "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:08_val"
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_val_680" <- do
        "idr_{APPLY_0}0.14" <- pure "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:02"
        "idr_{APPLY_0}1.14" <- pure "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:03"
        "idr_{APPLY_0}0_val.14" <- fetch "idr_{APPLY_0}0.14"
        case "idr_{APPLY_0}0_val.14" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.14" "idr_{APPLY_0}3.14" "idr_{APPLY_0}4.14") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.14" "idr_{APPLY_0}3.14" "idr_{APPLY_0}4.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.14") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.14") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.14") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.14" "idr_{APPLY_0}3_637.14") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.14" "idr_{APPLY_0}3_637.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.14"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.14" "idr_{APPLY_0}3_639.14" "idr_{APPLY_0}4_640.14" "idr_{APPLY_0}5.14") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.14" "idr_{APPLY_0}4_640.14" "idr_{APPLY_0}5.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.14") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.14"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.14" "idr_{APPLY_0}3_643.14" "idr_{APPLY_0}4_644.14") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.14" "idr_{APPLY_0}3_643.14" "idr_{APPLY_0}4_644.14"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.14"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.14") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.14" "idr_{APPLY_0}3_648.14") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.14" "idr_{APPLY_0}3_648.14" "idr_{APPLY_0}1.14"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.14")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.14")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.14")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.14") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.14" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.14" "idr_{APPLY_0}1.14")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.14")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.14") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.14" "idr_{APPLY_0}1.14") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.14" "idr_{APPLY_0}1.14")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09" <- store "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_val_680"
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_val" <- do
        "idr_{APPLY_0}0.15" <- pure "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09"
        "idr_{APPLY_0}1.15" <- pure "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:05"
        "idr_{APPLY_0}0_val.15" <- fetch "idr_{APPLY_0}0.15"
        case "idr_{APPLY_0}0_val.15" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.15" "idr_{APPLY_0}3.15" "idr_{APPLY_0}4.15") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.15" "idr_{APPLY_0}3.15" "idr_{APPLY_0}4.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.15") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.15") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.15") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.15" "idr_{APPLY_0}3_637.15") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.15" "idr_{APPLY_0}3_637.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.15"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.15" "idr_{APPLY_0}3_639.15" "idr_{APPLY_0}4_640.15" "idr_{APPLY_0}5.15") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.15" "idr_{APPLY_0}4_640.15" "idr_{APPLY_0}5.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.15") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.15"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.15" "idr_{APPLY_0}3_643.15" "idr_{APPLY_0}4_644.15") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.15" "idr_{APPLY_0}3_643.15" "idr_{APPLY_0}4_644.15"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.15"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.15") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.15" "idr_{APPLY_0}3_648.15") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.15" "idr_{APPLY_0}3_648.15" "idr_{APPLY_0}1.15"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.15")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.15")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.15")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.15") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.15" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.15" "idr_{APPLY_0}1.15")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.15")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.15") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.15" "idr_{APPLY_0}1.15") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.15" "idr_{APPLY_0}1.15")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_681" <- store "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_val"
      "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:0" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:02" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:09_681" "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:06"
    (Cidr_Prelude.List.Nil) ->
      fetch "idr_Prelude.Foldable.Prelude.List.@Prelude.Foldable.Foldable$List:!foldl:03"

"idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:0" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:03" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:04" =
  "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:04_val" <- fetch "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:04"
  case "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:04_val" of
    (Cidr_Data.Vect.:: "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:05" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:06") ->
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:07_val" <- do
        "idr_{APPLY_0}0.16" <- pure "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:03"
        "idr_{APPLY_0}1.16" <- pure "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:05"
        "idr_{APPLY_0}0_val.16" <- fetch "idr_{APPLY_0}0.16"
        case "idr_{APPLY_0}0_val.16" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.16" "idr_{APPLY_0}3.16" "idr_{APPLY_0}4.16") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.16" "idr_{APPLY_0}3.16" "idr_{APPLY_0}4.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.16") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.16") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.16") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.16" "idr_{APPLY_0}3_637.16") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.16" "idr_{APPLY_0}3_637.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.16"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.16" "idr_{APPLY_0}3_639.16" "idr_{APPLY_0}4_640.16" "idr_{APPLY_0}5.16") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.16" "idr_{APPLY_0}4_640.16" "idr_{APPLY_0}5.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.16") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.16"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.16" "idr_{APPLY_0}3_643.16" "idr_{APPLY_0}4_644.16") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.16" "idr_{APPLY_0}3_643.16" "idr_{APPLY_0}4_644.16"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.16"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.16") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.16" "idr_{APPLY_0}3_648.16") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.16" "idr_{APPLY_0}3_648.16" "idr_{APPLY_0}1.16"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.16")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.16")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.16")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.16") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.16" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.16" "idr_{APPLY_0}1.16")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.16")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.16") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.16" "idr_{APPLY_0}1.16") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.16" "idr_{APPLY_0}1.16")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:07" <- store "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:07_val"
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_val_682" <- pure (CErased)
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08" <- store "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_val_682"
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:09_val" <- pure (CErased)
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:09" <- store "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:09_val"
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:010_val" <- pure (CErased)
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:010" <- store "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:010_val"
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_val" <- "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:0" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:03" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:06"
      "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_683" <- store "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_val"
      pure (Cidr_Data.Vect.:: "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:07" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_683") -- LINT: Last return expressions can only return non-node values: pure (Cidr_Data.Vect.:: "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:07" "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:08_683")
    (Cidr_Data.Vect.Nil) ->
      fetch "idr_Prelude.Functor.Data.Vect.@Prelude.Functor.Functor$Vect n:!map:04"

"idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01" =
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02_val" <- do
    unboxed.CGrInt.49 <- idris_int_eq.unboxed "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01"
    pure (CGrInt unboxed.CGrInt.49) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.49)
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02" <- store "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02_val"
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02_val_684" <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02"
  case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:02_val_684" of
    (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0_cpat_LInt64_0") ->
      case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0_cpat_LInt64_0" of
        0 ->
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03_val" <- do
            unboxed.CGrInt.50 <- do
              (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01.32.45.arity.1") <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01"
              idris_int_lt.unboxed "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01.32.45.arity.1" -- LINT: The result of Fetch can only be bound to a variable: (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:01.32.45.arity.1")
            pure (CGrInt unboxed.CGrInt.50) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.50)
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03" <- store "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03_val"
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03_val_685" <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03"
          case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:03_val_685" of
            (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0_cpat_LInt64_0_686") ->
              case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Char:!compare:0_cpat_LInt64_0_686" of
                0 ->
                  pure (Cidr_Prelude.Interfaces.GT) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.GT)
                #default ->
                  pure (Cidr_Prelude.Interfaces.LT) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.LT)
        #default ->
          pure (Cidr_Prelude.Interfaces.EQ) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.EQ)

"idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01" =
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02_val" <- do
    unboxed.CGrInt.51 <- idris_int_eq.unboxed "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01"
    pure (CGrInt unboxed.CGrInt.51) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.51)
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02" <- store "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02_val"
  "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02_val_687" <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02"
  case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:02_val_687" of
    (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0_cpat_LInt64_0") ->
      case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0_cpat_LInt64_0" of
        0 ->
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03_val" <- do
            unboxed.CGrInt.52 <- do
              (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01.32.46.arity.1") <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01"
              idris_int_lt.unboxed "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:00" "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01.32.46.arity.1" -- LINT: The result of Fetch can only be bound to a variable: (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:01.32.46.arity.1")
            pure (CGrInt unboxed.CGrInt.52) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.52)
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03" <- store "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03_val"
          "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03_val_688" <- fetch "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03"
          case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:03_val_688" of
            (CGrInt "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0_cpat_LInt64_0_689") ->
              case "idr_Prelude.Interfaces.Prelude.Interfaces.@Prelude.Interfaces.Ord$Integer:!compare:0_cpat_LInt64_0_689" of
                0 ->
                  pure (Cidr_Prelude.Interfaces.GT) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.GT)
                #default ->
                  pure (Cidr_Prelude.Interfaces.LT) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.LT)
        #default ->
          pure (Cidr_Prelude.Interfaces.EQ) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Interfaces.EQ)

idr__Prelude.Strings.unpack_with_36 idr__Prelude.Strings.unpack_with_361 =
  idr__Prelude.Strings.unpack_with_361_val <- fetch idr__Prelude.Strings.unpack_with_361
  case idr__Prelude.Strings.unpack_with_361_val of
    (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.unpack_with_362 idr__Prelude.Strings.unpack_with_363) ->
      idr__Prelude.Strings.unpack_with_364_val_690 <- pure (CErased)
      idr__Prelude.Strings.unpack_with_364 <- store idr__Prelude.Strings.unpack_with_364_val_690
      idr__Prelude.Strings.unpack_with_365_val_694 <- pure (CGrString #"")
      idr__Prelude.Strings.unpack_with_365 <- store idr__Prelude.Strings.unpack_with_365_val_694
      idr__Prelude.Strings.unpack_with_365_val_693 <- do
        unboxed.CGrInt.53 <- do
          (CGrString idr__Prelude.Strings.unpack_with_365.32.47.arity.1) <- fetch idr__Prelude.Strings.unpack_with_365
          idris_str_eq.unboxed idr__Prelude.Strings.unpack_with_363 idr__Prelude.Strings.unpack_with_365.32.47.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr__Prelude.Strings.unpack_with_365.32.47.arity.1)
        pure (CGrInt unboxed.CGrInt.53) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.53)
      idr__Prelude.Strings.unpack_with_365_695 <- store idr__Prelude.Strings.unpack_with_365_val_693
      idr__Prelude.Strings.unpack_with_365_val_696 <- fetch idr__Prelude.Strings.unpack_with_365_695
      idr__Prelude.Strings.unpack_with_365_val_692 <- case idr__Prelude.Strings.unpack_with_365_val_696 of
        (CGrInt idr__Prelude.Strings.unpack_with_36_cpat_LInt64_0) ->
          case idr__Prelude.Strings.unpack_with_36_cpat_LInt64_0 of
            0 ->
              pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
            #default ->
              pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
      idr__Prelude.Strings.unpack_with_365_697 <- store idr__Prelude.Strings.unpack_with_365_val_692
      idr__Prelude.Strings.unpack_with_366_val <- pure (Cidr_Prelude.Bool.True)
      idr__Prelude.Strings.unpack_with_366 <- store idr__Prelude.Strings.unpack_with_366_val
      idr__Prelude.Strings.unpack_with_365_val_691 <- do
        (Cidr_Prelude.Bool.True) <- fetch idr__Prelude.Strings.unpack_with_366
        "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr__Prelude.Strings.unpack_with_365_697 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
      idr__Prelude.Strings.unpack_with_365_698 <- store idr__Prelude.Strings.unpack_with_365_val_691
      idr__Prelude.Strings.unpack_with_365_val_699 <- fetch idr__Prelude.Strings.unpack_with_365_698
      idr__Prelude.Strings.unpack_with_365_val <- case idr__Prelude.Strings.unpack_with_365_val_699 of
        (Cidr_Prelude.Basics.No) ->
          pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
        (Cidr_Prelude.Basics.Yes) ->
          idr__Prelude.Strings.unpack_with_366_val_700 <- do
            unboxed.CGrInt.54 <- idris_str_head.unboxed idr__Prelude.Strings.unpack_with_363
            pure (CGrInt unboxed.CGrInt.54) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.54)
          idr__Prelude.Strings.unpack_with_366_701 <- store idr__Prelude.Strings.unpack_with_366_val_700
          idr__Prelude.Strings.unpack_with_367_val <- do
            unboxed.CGrString.47 <- idris_str_tail.unboxed idr__Prelude.Strings.unpack_with_363
            pure (CGrString unboxed.CGrString.47) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.47)
          idr__Prelude.Strings.unpack_with_367 <- store idr__Prelude.Strings.unpack_with_367_val
          pure (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.unpack_with_366_701 idr__Prelude.Strings.unpack_with_367) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.unpack_with_366_701 idr__Prelude.Strings.unpack_with_367)
      idr__Prelude.Strings.unpack_with_365_702 <- store idr__Prelude.Strings.unpack_with_365_val
      idr__Prelude.Strings.unpack_with_364_val <- idr__Prelude.Strings.unpack_with_36 idr__Prelude.Strings.unpack_with_365_702
      idr__Prelude.Strings.unpack_with_364_703 <- store idr__Prelude.Strings.unpack_with_364_val
      pure (Cidr_Prelude.List.:: idr__Prelude.Strings.unpack_with_362 idr__Prelude.Strings.unpack_with_364_703) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.:: idr__Prelude.Strings.unpack_with_362 idr__Prelude.Strings.unpack_with_364_703)
    (Cidr_Prelude.Strings.StrNil) ->
      pure (Cidr_Prelude.List.Nil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.List.Nil)

idr__Prelude.Strings.span_with_50 idr__Prelude.Strings.span_with_500 idr__Prelude.Strings.span_with_502 =
  idr__Prelude.Strings.span_with_502_val <- fetch idr__Prelude.Strings.span_with_502
  case idr__Prelude.Strings.span_with_502_val of
    (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.span_with_503 idr__Prelude.Strings.span_with_504) ->
      idr__Prelude.Strings.span_with_505_val <- do
        "idr_{APPLY_0}0.17" <- pure idr__Prelude.Strings.span_with_500
        "idr_{APPLY_0}1.17" <- pure idr__Prelude.Strings.span_with_503
        "idr_{APPLY_0}0_val.17" <- fetch "idr_{APPLY_0}0.17"
        case "idr_{APPLY_0}0_val.17" of
          (C"idr_{U_Data.Vect.{foldrImpl_2}_1}" "idr_{APPLY_0}2.17" "idr_{APPLY_0}3.17" "idr_{APPLY_0}4.17") ->
            "idr_Data.Vect.{foldrImpl_2}" "idr_{APPLY_0}2.17" "idr_{APPLY_0}3.17" "idr_{APPLY_0}4.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Data.Vect.{range_5}_1}") ->
            "idr_Data.Vect.{range_5}" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}2_633.17") ->
            idr_Main.processInput "idr_{APPLY_0}2_633.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}2_634.17") ->
            "idr_Main.{parseCommand_4}" "idr_{APPLY_0}2_634.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.{parse_3}_1}") ->
            "idr_Main.{parse_3}" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}2_635.17") ->
            "idr_Main.{search_10}" "idr_{APPLY_0}2_635.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_636.17" "idr_{APPLY_0}3_637.17") ->
            "idr_Main.{search_8}" "idr_{APPLY_0}2_636.17" "idr_{APPLY_0}3_637.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.{search_9}_1}") ->
            "idr_Main.{search_9}" "idr_{APPLY_0}1.17"
          (C"idr_{U_Prelude.Interactive.replWith_1}" "idr_{APPLY_0}2_638.17" "idr_{APPLY_0}3_639.17" "idr_{APPLY_0}4_640.17" "idr_{APPLY_0}5.17") ->
            idr_Prelude.Interactive.replWith "idr_{APPLY_0}3_639.17" "idr_{APPLY_0}4_640.17" "idr_{APPLY_0}5.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Prelude.Interactive.{replWith_6}_1}" "idr_{APPLY_0}2_641.17") ->
            "idr_Prelude.Interactive.{replWith_6}" "idr_{APPLY_0}2_641.17"
          (C"idr_{U_Prelude.Interactive.{replWith_7}_1}" "idr_{APPLY_0}2_642.17" "idr_{APPLY_0}3_643.17" "idr_{APPLY_0}4_644.17") ->
            "idr_Prelude.Interactive.{replWith_7}" "idr_{APPLY_0}2_642.17" "idr_{APPLY_0}3_643.17" "idr_{APPLY_0}4_644.17"
          (C"idr_{U_prim__toStrBigInt_1}") ->
            idr_prim__toStrBigInt "idr_{APPLY_0}1.17"
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}2_646.17") ->
            "idr_{PE_isInfixOf_22f242c8_0}" "idr_{APPLY_0}2_646.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_647.17" "idr_{APPLY_0}3_648.17") ->
            "idr_{PE_isInfixOf_22f242c8_1}" "idr_{APPLY_0}2_647.17" "idr_{APPLY_0}3_648.17" "idr_{APPLY_0}1.17"
          (C"idr_{U_Main.processInput_2}") ->
            pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.processInput_1}" "idr_{APPLY_0}1.17")
          (C"idr_{U_Main.{parseCommand_4}_2}") ->
            pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{parseCommand_4}_1}" "idr_{APPLY_0}1.17")
          (C"idr_{U_Main.{search_10}_2}") ->
            pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_10}_1}" "idr_{APPLY_0}1.17")
          (C"idr_{U_Main.{search_8}_2}" "idr_{APPLY_0}2_649.17") ->
            pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.17" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_Main.{search_8}_1}" "idr_{APPLY_0}2_649.17" "idr_{APPLY_0}1.17")
          (C"idr_{U_{PE_isInfixOf_22f242c8_0}_2}") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_0}_1}" "idr_{APPLY_0}1.17")
          (C"idr_{U_{PE_isInfixOf_22f242c8_1}_2}" "idr_{APPLY_0}2_650.17") ->
            pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.17" "idr_{APPLY_0}1.17") -- LINT: Last return expressions can only return non-node values: pure (C"idr_{U_{PE_isInfixOf_22f242c8_1}_1}" "idr_{APPLY_0}2_650.17" "idr_{APPLY_0}1.17")
          #default ->
            pure (CErased) -- LINT: Last return expressions can only return non-node values: pure (CErased)
      idr__Prelude.Strings.span_with_505 <- store idr__Prelude.Strings.span_with_505_val
      idr__Prelude.Strings.span_with_505_val_704 <- fetch idr__Prelude.Strings.span_with_505
      case idr__Prelude.Strings.span_with_505_val_704 of
        (Cidr_Prelude.Bool.False) ->
          idr__Prelude.Strings.span_with_506_val <- pure (CGrString #"")
          idr__Prelude.Strings.span_with_506 <- store idr__Prelude.Strings.span_with_506_val
          idr__Prelude.Strings.span_with_507_val <- do
            unboxed.CGrString.48 <- do
              (CGrInt idr__Prelude.Strings.span_with_503.32.49.arity.1) <- fetch idr__Prelude.Strings.span_with_503
              (CGrString idr__Prelude.Strings.span_with_504.32.49.arity.1) <- fetch idr__Prelude.Strings.span_with_504
              idris_str_cons.unboxed idr__Prelude.Strings.span_with_503.32.49.arity.1 idr__Prelude.Strings.span_with_504.32.49.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr__Prelude.Strings.span_with_504.32.49.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr__Prelude.Strings.span_with_503.32.49.arity.1)
            pure (CGrString unboxed.CGrString.48) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.48)
          idr__Prelude.Strings.span_with_507 <- store idr__Prelude.Strings.span_with_507_val
          pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_506 idr__Prelude.Strings.span_with_507) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_506 idr__Prelude.Strings.span_with_507)
        (Cidr_Prelude.Bool.True) ->
          idr__Prelude.Strings.span_with_506_val_706 <- pure (CErased)
          idr__Prelude.Strings.span_with_506_707 <- store idr__Prelude.Strings.span_with_506_val_706
          idr__Prelude.Strings.span_with_507_val_712 <- pure (CGrString #"")
          idr__Prelude.Strings.span_with_507_713 <- store idr__Prelude.Strings.span_with_507_val_712
          idr__Prelude.Strings.span_with_507_val_711 <- do
            unboxed.CGrInt.55 <- do
              (CGrString idr__Prelude.Strings.span_with_507_713.32.50.arity.1) <- fetch idr__Prelude.Strings.span_with_507_713
              idris_str_eq.unboxed idr__Prelude.Strings.span_with_504 idr__Prelude.Strings.span_with_507_713.32.50.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr__Prelude.Strings.span_with_507_713.32.50.arity.1)
            pure (CGrInt unboxed.CGrInt.55) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.55)
          idr__Prelude.Strings.span_with_507_714 <- store idr__Prelude.Strings.span_with_507_val_711
          idr__Prelude.Strings.span_with_507_val_715 <- fetch idr__Prelude.Strings.span_with_507_714
          idr__Prelude.Strings.span_with_507_val_710 <- case idr__Prelude.Strings.span_with_507_val_715 of
            (CGrInt idr__Prelude.Strings.span_with_50_cpat_LInt64_0) ->
              case idr__Prelude.Strings.span_with_50_cpat_LInt64_0 of
                0 ->
                  pure (Cidr_Prelude.Bool.True) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.True)
                #default ->
                  pure (Cidr_Prelude.Bool.False) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Bool.False)
          idr__Prelude.Strings.span_with_507_716 <- store idr__Prelude.Strings.span_with_507_val_710
          idr__Prelude.Strings.span_with_508_val <- pure (Cidr_Prelude.Bool.True)
          idr__Prelude.Strings.span_with_508 <- store idr__Prelude.Strings.span_with_508_val
          idr__Prelude.Strings.span_with_507_val_709 <- do
            (Cidr_Prelude.Bool.True) <- fetch idr__Prelude.Strings.span_with_508
            "idr_Decidable.Equality.Decidable.Equality.@Decidable.Equality.DecEq$Bool:!decEq:0" idr__Prelude.Strings.span_with_507_716 -- LINT: The result of Fetch can only be bound to a variable: (Cidr_Prelude.Bool.True)
          idr__Prelude.Strings.span_with_507_717 <- store idr__Prelude.Strings.span_with_507_val_709
          idr__Prelude.Strings.span_with_507_val_718 <- fetch idr__Prelude.Strings.span_with_507_717
          idr__Prelude.Strings.span_with_507_val_708 <- case idr__Prelude.Strings.span_with_507_val_718 of
            (Cidr_Prelude.Basics.No) ->
              pure (Cidr_Prelude.Strings.StrNil) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrNil)
            (Cidr_Prelude.Basics.Yes) ->
              idr__Prelude.Strings.span_with_508_val_719 <- do
                unboxed.CGrInt.56 <- idris_str_head.unboxed idr__Prelude.Strings.span_with_504
                pure (CGrInt unboxed.CGrInt.56) -- LINT: Last return expressions can only return non-node values: pure (CGrInt unboxed.CGrInt.56)
              idr__Prelude.Strings.span_with_508_720 <- store idr__Prelude.Strings.span_with_508_val_719
              idr__Prelude.Strings.span_with_509_val <- do
                unboxed.CGrString.49 <- idris_str_tail.unboxed idr__Prelude.Strings.span_with_504
                pure (CGrString unboxed.CGrString.49) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.49)
              idr__Prelude.Strings.span_with_509 <- store idr__Prelude.Strings.span_with_509_val
              pure (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.span_with_508_720 idr__Prelude.Strings.span_with_509) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Prelude.Strings.StrCons idr__Prelude.Strings.span_with_508_720 idr__Prelude.Strings.span_with_509)
          idr__Prelude.Strings.span_with_507_721 <- store idr__Prelude.Strings.span_with_507_val_708
          idr__Prelude.Strings.span_with_506_val_705 <- idr__Prelude.Strings.span_with_50 idr__Prelude.Strings.span_with_500 idr__Prelude.Strings.span_with_507_721
          idr__Prelude.Strings.span_with_506_722 <- store idr__Prelude.Strings.span_with_506_val_705
          idr__Prelude.Strings.span_with_506_val_723 <- fetch idr__Prelude.Strings.span_with_506_722
          (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_507_724 idr__Prelude.Strings.span_with_508_725) <- pure idr__Prelude.Strings.span_with_506_val_723
          idr__Prelude.Strings.span_with_509_val_726 <- do
            unboxed.CGrString.50 <- do
              (CGrInt idr__Prelude.Strings.span_with_503.32.52.arity.1) <- fetch idr__Prelude.Strings.span_with_503
              (CGrString idr__Prelude.Strings.span_with_507_724.32.52.arity.1) <- fetch idr__Prelude.Strings.span_with_507_724
              idris_str_cons.unboxed idr__Prelude.Strings.span_with_503.32.52.arity.1 idr__Prelude.Strings.span_with_507_724.32.52.arity.1 -- LINT: The result of Fetch can only be bound to a variable: (CGrString idr__Prelude.Strings.span_with_507_724.32.52.arity.1) -- LINT: The result of Fetch can only be bound to a variable: (CGrInt idr__Prelude.Strings.span_with_503.32.52.arity.1)
            pure (CGrString unboxed.CGrString.50) -- LINT: Last return expressions can only return non-node values: pure (CGrString unboxed.CGrString.50)
          idr__Prelude.Strings.span_with_509_727 <- store idr__Prelude.Strings.span_with_509_val_726
          pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_509_727 idr__Prelude.Strings.span_with_508_725) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_509_727 idr__Prelude.Strings.span_with_508_725)
    (Cidr_Prelude.Strings.StrNil) ->
      idr__Prelude.Strings.span_with_503_val <- pure (CGrString #"")
      idr__Prelude.Strings.span_with_503_728 <- store idr__Prelude.Strings.span_with_503_val
      idr__Prelude.Strings.span_with_504_val <- pure (CGrString #"")
      idr__Prelude.Strings.span_with_504_729 <- store idr__Prelude.Strings.span_with_504_val
      pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_503_728 idr__Prelude.Strings.span_with_504_729) -- LINT: Last return expressions can only return non-node values: pure (Cidr_Builtins.MkPair idr__Prelude.Strings.span_with_503_728 idr__Prelude.Strings.span_with_504_729)
